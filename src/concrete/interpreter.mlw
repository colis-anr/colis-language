(** {1 An imperative interpreter of the CoLiS Language}

    See NOTES[Concrete interpreter type] for discussion on arguments.
 *)

module Interpreter

  use list.List
  use list.Append
  use ref.Ref
  use option.Option
  use bool.Bool
  use array.Array
  use map.MapExt

  use mystring.String
  use syntax.Syntax
  use semantics.Filesystem
  use semantics.Buffers
  use semantics.Behaviour
  use semantics.Environment
  use semantics.Context as C
  use semantics.Semantics

  (** {3 A purely imparative state} *)

  (* We use refs instead of mutable fields to be able to reuse `stdin` (and `stdout`) but
     shadow `senv`. *)
  type state = {
    senv : ref (env string);
    stdin : ref stdin;
    stdout : ref stdout;
    filesystem : ref filesystem;
    result : ref bool;
  }

  let empty_state () = {
    senv = ref empty_env;
    stdin = ref empty_stdin;
    stdout = ref empty_stdout;
    filesystem = ref empty_filesystem;
    result = ref True;
  }

  (** {4 Conversion to `semantics.Context`} *)

  function context (sta:state) : Context.context = {
    Context.senv = !(sta.senv)
  }

  lemma context_same: forall sta1 sta2.
    !(sta1.senv) == !(sta2.senv) ->
    context sta1 = context sta2

  let function state (sta:state) : Context.state = {
    Context.filesystem = !(sta.filesystem);
    Context.stdin = !(sta.stdin);
    Context.stdout = !(sta.stdout)
  }

  (** {3 The input type} *)

  type input = {
    arguments: array string;
    under_condition: bool;
  }

  let constant empty_input = {
    arguments = Array.make 0 String.empty;
    under_condition = False;
  }

  let function input (inp:input) (sta:state) : Context.input = {
    Context.arguments = inp.arguments;
    Context.under_condition = inp.under_condition;
    Context.previous_result = !(sta.result);
  }

  lemma input_same : forall inp inp' sta sta'.
    inp.arguments = inp'.arguments ->
    inp.under_condition = inp'.under_condition ->
    !(sta.result) = !(sta'.result) ->
    input inp sta = input inp' sta'

  (** {3 The exit exception} *)

  exception EExit

  let maybe_exit (inp:input) (sta:state) : unit
    returns { () ->
      inject_behaviour (input inp sta) !(sta.result) = BNormal !(sta.result)
    }
    raises { EExit ->
      inject_behaviour (input inp sta) !(sta.result) = BExit !(sta.result)
    }
  = if andb (strict inp.under_condition) (notb !(sta.result)) then
      raise EExit

  (** {3 Imperative wrapper around the functional interpretation of builtin} *)

  let interp_builtin inp sta name args raises { EExit -> true }
  = let sta', b = Semantics.interp_builtin (state sta) name args in
    sta.filesystem := sta'.Context.filesystem;
    sta.stdin := sta'.Context.stdin;
    sta.stdout := sta'.Context.stdout;
    sta.result := b;
    maybe_exit inp sta
  
  (** {3 The interpretation of statements} *)

  let rec interp_instruction (inp:input) (sta:state) (ins:instruction) : unit
    diverges
    returns { () ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (BNormal !(sta.result))
    }
    raises { EExit ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (BExit !(sta.result))
    }
  = label L in match ins with

    | IExit code ->
      match code with
      | RPrevious -> ()
      | RSuccess -> sta.result := True
      | RFailure -> sta.result := False
      end;
      assert { !(sta.result) = bool_of_return_code code !(sta.result at L) };
      raise EExit

    | IAssignment var se ->
      let str, bo = interp_str_expr inp sta se in
      sta.senv := !(sta.senv)[var <- str];
      sta.result := option_get True bo;
      maybe_exit inp sta

    | ISequence ins1 ins2 ->
      interp_instruction inp sta ins1;
      interp_instruction inp sta ins2

    | ISubshell ins ->
      (* Don't change `sta.senv` in the subshell *)
      let sta' = {sta with senv = ref !(sta.senv)} in
      try interp_instruction inp sta' ins with EExit -> () end;
      maybe_exit inp sta

    | INot ins ->
      interp_instruction {inp with under_condition=True} sta ins;
      sta.result := notb !(sta.result)
      (* TODO Flip sta.result when interp_instruction raises Exit? *)

    | IIf ins1 ins2 ins3 ->
      interp_instruction {inp with under_condition=True} sta ins1;
      if !(sta.result) then
        interp_instruction inp sta ins2
      else
        interp_instruction inp sta ins3

    | INoOutput ins ->
      (* Donâ€™t write to `sta.stdout` *)
      let sta' = {sta with stdout = ref empty_stdout} in
      interp_instruction inp sta' ins

    | IPipe ins1 ins2 ->
      let sta' = {sta with stdout = ref empty_stdout; senv = ref !(sta.senv)} in
      try interp_instruction inp sta' ins1 with EExit _ -> () end;
      let sta'' = {sta' with stdout = sta.stdout; stdin = ref (stdout_to_stdin !(sta'.stdout)); senv = ref !(sta.senv)} in
      interp_instruction inp sta'' ins2

    | ICall name le ->
      let args = interp_list_expr inp sta le in
      interp_builtin inp sta name args

    | IForeach var le ins ->
      let ss = interp_list_expr inp sta le in
      let last_result = ref True in
      let rec foreach ss =
        match ss with
        | Nil -> ()
        | Cons s ss' ->
          sta.senv := !(sta.senv)[var <- s];
          interp_instruction inp sta ins;
          last_result := !(sta.result);
          foreach ss'
        end
      in foreach ss;
      sta.result := !last_result (* See NOTES[Previous in for-loop] for p=True *)

    | IWhile ins1 ins2 ->
      let last_result = ref True in
      while (
        interp_instruction {inp with under_condition=True} sta ins1;
        !(sta.result)
      ) do
        interp_instruction inp sta ins2;
        last_result := !(sta.result);
      done;
      sta.result := !last_result
    end

  with interp_str_expr (inp:input) (sta:state) (se:string_expression) : (string, option bool)
    diverges
    ensures { context sta = context (old sta) }
    returns { s, bo ->
      eval_str_expr (input inp (old sta)) (context (old sta)) (state (old sta))
        se (state sta) s bo
    }
  = match se with

    | SLiteral s ->
      s, None

    | SVariable v ->
      !(sta.senv) v, None  (* Why3 bug: Map__Map is not created - cannot use ctx.senv[v] *)

    | SSubshell ins ->
      (* TODO `result = ref True`: differences between shells *)
      let sta' = {sta with stdout = ref empty_stdout; result = ref !(sta.result); senv = ref !(sta.senv)} in
      try interp_instruction inp sta' ins with EExit -> () end;
      stdout_to_string !(sta'.stdout), Some !(sta'.result)

    | SConcat se1 se2 ->
      label L1 in let s1, bo1 = interp_str_expr inp sta se1 in
      assert { eval_str_expr (input inp (sta at L1)) (context (sta at L1)) (state (sta at L1)) se1 (state sta) s1 bo1 };
      label L2 in let s2, bo2 = interp_str_expr inp sta se2 in
      assert { eval_str_expr (input inp (sta at L1)) (context (sta at L2)) (state (sta at L2)) se2 (state sta) s2 bo2 };
      let bo3 = bool_opt_compose bo1 bo2 in
      s1^s2, bo3
    end

  with interp_list_expr (inp:input) (sta:state) (le:list_expression) : list string
    diverges
    ensures { context sta = context (old sta) }
    returns { ss ->
      eval_list_expr (input inp (old sta)) (context (old sta)) (state (old sta))
        le (state sta) ss
    }
  = match le with
    | Nil -> Nil
    | Cons (se, sp) le_rest ->
      let s, _ = interp_str_expr inp sta se in
      let l1 = match sp with Split -> String.split_on_default_ifs s | DontSplit -> Cons s Nil end in
      let l2 = interp_list_expr inp sta le_rest in
      l1 ++ l2
    end

  let interp_program inp sta pro
    diverges
    returns { () ->
      eval_program (input inp (old sta)) (context (old sta)) (state (old sta))
        pro (state sta) (context sta) !(sta.result)
    }
  = try interp_instruction inp sta pro
    with EExit -> () end
end