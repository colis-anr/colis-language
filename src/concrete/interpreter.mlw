
module Stdout
  use ref.Ref
  use semantics.Buffers

  type stdout = ref Buffers.stdout

  let stdout_new () = ref Buffers.empty_stdout
end

module Interpreter

  use list.List
  use list.Append
  use ref.Ref
  use option.Option
  use bool.Bool

  use mystring.String
  use syntax.Syntax
  use semantics.Strict
  use semantics.Buffers
  use semantics.Behaviour
  use semantics.Context
  use semantics.Semantics
  use Stdout

  let ([<-]) (m:variable -> 'a) (var:variable) (value:'a) : variable -> 'a
  = fun var1 ->
      if variable_eq var1 var
      then value
      else m var1

  let interp_builtin out sta name args =
    let sta1, out1, b = Semantics.interp_builtin sta name args in
    out := append !out out1;
    sta1, b

  type result = (context, state, bool)

  exception EExit result
  
  let result_or_exit (strict:strict) (ctx:context) (sta:state) (b:bool) : result
    raises { EExit _ -> true }
  = match strict, b with
    | Strict True, False -> raise (EExit (ctx, sta, b))
    | _ -> ctx, sta, b
    end

  let result_or_exit_opt (strict:strict) (ctx:context) (sta:state) (bo:option bool) : result
    raises { EExit _ -> true }
  = match bo with
    | Some b -> result_or_exit strict ctx sta b
    | None -> ctx, sta, True
    end
  
  (* See NOTES[Concrete interpreter type] for discussion on arguments *)
  let rec interp_stmt (inp:input) (out:stdout) (ctx:context) (sta:state) (stm:instruction) : result
    returns { ctx', sta', b -> eval_stmt inp ctx sta stm sta' ctx' {stdout=diff !out (old !out); behaviour=BNormal b} }
    raises  { EExit (ctx', sta', b) -> eval_stmt inp ctx sta stm sta' ctx' {stdout=diff !out (old !out); behaviour=BExit b} }
    raises  { EExit _ -> not inp.under_condition }
  = match stm with

    | SExit code ->
      raise EExit (ctx, sta, bool_of_return_code code inp.previous)

    | SAssignment var se ->
      let sta1, str, bo = interp_str_expr inp ctx sta se in
      let ctx1 = {ctx with senv = ctx.senv[var <- str]} in
      result_or_exit_opt (strict inp) ctx1 sta1 bo

    | SSequence stm1 stm2 ->
      let ctx1, sta1, b = interp_stmt inp out ctx sta stm1 in
      interp_stmt {inp with previous = b} out ctx1 sta1 stm2

    | SSubshell stm ->
      let ctx1, sta1, b = interp_stmt inp out ctx sta stm in
      result_or_exit (strict inp) ctx1 sta1 b

    | SNot stm ->
      let ctx1, sta1, b = interp_stmt {inp with under_condition=True} out ctx sta stm in
      ctx1, sta1, (notb b)

    | SIf stm1 stm2 stm3 ->
      let ctx1, sta1, b = interp_stmt {inp with under_condition=True} out ctx sta stm1 in
      if b then
        interp_stmt inp out ctx1 sta1 stm2
      else
        interp_stmt inp out ctx1 sta1 stm3

    | SNoOutput stm ->
      interp_stmt inp (stdout_new ()) ctx sta stm

    | SPipe stm1 stm2 ->
      let ctx1, sta1, _ =
        try interp_stmt inp out ctx sta stm1
        with EExit r -> r end
      in
      interp_stmt inp out ctx1 sta1 stm2

    | SCall name le ->
      let sta1, args = interp_list_expr inp ctx sta le in
      let sta2, b = interp_builtin out sta1 name args in
      result_or_exit (strict inp) ctx sta2 b

    | SForeach var le stm ->
      let sta1, ss = interp_list_expr inp ctx sta le in
      let rec aux ctx sta p ss =
        match ss with
        | Nil -> ctx, sta, p
        | Cons s ss' ->
          let ctx' = {ctx with senv = ctx.senv[var <- s] } in
          let ctx'', sta', b = interp_stmt {inp with previous=p} out ctx' sta stm in
          aux ctx'' sta' b ss'
        end
      (* See NOTES[Previous in for-loop] for p=True *)
      in aux ctx sta1 True ss

    | SWhile _ _ -> absurd
    end

  with interp_str_expr (inp:input) (ctx:context) (sta:state) (se:string_expression) : (state, string, option bool)
  = match se with
    | ELiteral s -> sta, s, None
    | EVariable v -> sta, ctx.senv v, None  (* Why3 bug: Map__Map is not created - cannot use ctx.senv[v] *)
    | ESubshell stm ->
      let out = stdout_new () in
      let _, sta1, b =
        try interp_stmt inp out ctx sta stm
        with EExit res -> res end
      in
      let str = string_from_stdout !out in
      sta1, str, Some b
    | EConcat se1 se2 ->
      let sta1, s1, bo1 = interp_str_expr inp ctx sta se1 in
      let sta2, s2, bo2 = interp_str_expr inp ctx sta1 se2 in
      let bo3 = bool_opt_compose bo1 bo2 in
      sta2, s1^s2, bo3
    end

  with interp_list_expr (inp:input) (ctx:context) (sta:state) (le:list_expression) : (state, list string)
  = match le with
    | Nil -> sta, Nil
    | Cons (se, sp) le_rest ->
      let sta1, s, _ = interp_str_expr inp ctx sta se in
      let l1 = match sp with Split True -> split s | Split False -> Cons s Nil end in
      let sta2, l2 = interp_list_expr inp ctx sta1 le_rest in
      let l3 = l1 ++ l2 in
      sta2, l3
    end
end