
(** {1 An imperative interpreter of the CoLiS Language}

    See NOTES[Concrete interpreter type] for discussion on arguments.
 *)

module Interpreter

  use list.List
  use list.Append
  use ref.Ref
  use option.Option
  use bool.Bool
  use array.Array

  use mystring.String
  use syntax.Syntax
  use semantics.Filesystem
  use semantics.Buffers
  use semantics.Behaviour
  use semantics.Context as C
  use semantics.Semantics

  let ([<-]) (m:variable -> 'a) (var:variable) (value:'a) : variable -> 'a
  = fun var1 ->
      if variable_eq var1 var
      then value
      else m var1

  (** {3 A purely imparative state} *)

  (* We use refs instead of mutable fields to be able to reuse `stdin` (and `stdout`) but
     shadow `senv`. *)
  type state = {
    senv : ref C.senv;
    stdin : ref stdin;
    stdout : ref stdout;
    filesystem : ref filesystem;
    result : ref bool;
  }

  let empty_state () = {
    senv = ref C.empty_senv;
    stdin = ref empty_stdin;
    stdout = ref empty_stdout;
    filesystem = ref empty_filesystem;
    result = ref True;
  }

  (** {4 Conversion to `semantics.Context`} *)

  function context (sta:state) : Context.context = {
    Context.senv = !(sta.senv)
  }

  let function state (sta:state) : Context.state = {
    Context.filesystem = !(sta.filesystem);
    Context.stdin = !(sta.stdin)
  }

  function normal_output (old_sta sta:state) : Context.output = {
    Context.behaviour = BNormal !(sta.result);
    Context.stdout = diff !(old_sta.stdout) !(sta.stdout)
  }

  function exit_output (old_sta sta:state) : Context.output = {
    Context.behaviour = BExit !(sta.result);
    Context.stdout = diff !(old_sta.stdout) !(sta.stdout)
  }

  (** {3 The input type} *)

  type input = {
    arguments: array string;
    under_condition: bool;
  }

  let constant empty_input = {
    arguments = Array.make 0 String.empty;
    under_condition = False;
  }

  let function input (inp:input) (sta:state) : Context.input = {
    Context.arguments = inp.arguments;
    Context.under_condition = inp.under_condition;
    Context.previous_result = !(sta.result);
  }

  (** {3 The exit exception} *)

  exception EExit

  let maybe_exit (inp:input) (sta:state) : unit
    raises { EExit -> true }
  = if andb (strict inp.under_condition) (notb !(sta.result))
    then raise EExit

  (** {3 Imperative wrapper around the functional interpretation of builtin} *)

  let interp_builtin inp sta name args raises { EExit -> true }
  = let sta', out, b = Semantics.interp_builtin (state sta) name args in
    sta.filesystem := sta'.Context.filesystem;
    sta.stdin := sta'.Context.stdin;
    sta.stdout := append !(sta.stdout) out;
    sta.result := b;
    maybe_exit inp sta
  
  (** {3 The interpretation of statements} *)

  let option_get default opt =
    match opt with Some x -> x | None -> default end

  let rec interp_instruction (inp:input) (sta:state) (ins:instruction) : unit
    returns { () ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (normal_output (old sta) sta)
    }
    raises { EExit ->
      eval_instruction (input inp (old sta)) (context (old sta)) (state (old sta))
        ins (state sta) (context sta) (exit_output (old sta) sta)
    }
  = match ins with

    | IExit code ->
      let b =
        match code with
        | RPrevious -> !(sta.result)
        | RFailure -> False
        | RSuccess -> True
        end
      in
      sta.result := b;
      raise EExit

    | IAssignment var se ->
      let str, bo = interp_str_expr inp sta se in
      sta.senv := !(sta.senv)[var <- str];
      sta.result := option_get True bo;
      maybe_exit inp sta

    | ISequence stm1 stm2 ->
      interp_instruction inp sta stm1;
      interp_instruction inp sta stm2

    | ISubshell stm ->
      (* Don't change `sta.senv` in the subshell *)
      let sta' = {sta with senv = ref !(sta.senv)} in
      interp_instruction inp sta' stm

    | INot stm ->
      interp_instruction {inp with under_condition=True} sta stm;
      sta.result := notb !(sta.result)
      (* TODO Flip sta.result when interp_instruction raises Exit? *)

    | IIf stm1 stm2 stm3 ->
      interp_instruction {inp with under_condition=True} sta stm1;
      if !(sta.result) then
        interp_instruction inp sta stm2
      else
        interp_instruction inp sta stm3

    | INoOutput stm ->
      (* Donâ€™t write to `sta.stdout` *)
      let sta' = {sta with stdout = ref empty_stdout} in
      interp_instruction inp sta' stm

    | IPipe stm1 stm2 ->
      let sta' = {sta with stdout = ref empty_stdout} in
      try interp_instruction inp sta' stm1 with EExit _ -> () end;
      let sta'' = {sta with stdin = ref (stdout_to_stdin !(sta'.stdout))} in
      interp_instruction inp sta'' stm2

    | ICall name le ->
      let args = interp_list_expr inp sta le in
      interp_builtin inp sta name args

    | IForeach var le stm ->
      let ss = interp_list_expr inp sta le in
      let rec aux ss =
        match ss with
        | Nil -> ()
        | Cons s ss' ->
          sta.senv := !(sta.senv)[var <- s];
          interp_instruction inp sta stm;
          aux ss'
        end
      in
      (* See NOTES[Previous in for-loop] for p=True *)
      sta.result := True;
      aux ss

    | IWhile _ _ -> absurd
    end

  with interp_str_expr (inp:input) (sta:state) (se:string_expression) : (string, option bool)
  = match se with
    | SLiteral s -> s, None
    | SVariable v -> !(sta.senv) v, None  (* Why3 bug: Map__Map is not created - cannot use ctx.senv[v] *)
    | SSubshell stm ->
      (* TODO `result = ref True`: differences between shells *)
      let sta' = {sta with stdout = ref empty_stdout; result = ref True} in
      try interp_instruction inp sta' stm with EExit -> () end;
      string_from_stdout !(sta'.stdout), Some !(sta'.result)
    | SConcat se1 se2 ->
      let s1, bo1 = interp_str_expr inp sta se1 in
      let s2, bo2 = interp_str_expr inp sta se2 in
      let bo3 = bool_opt_compose bo1 bo2 in
      s1^s2, bo3
    end

  with interp_list_expr (inp:input) (sta:state) (le:list_expression) : list string
  = match le with
    | Nil -> Nil
    | Cons (se, sp) le_rest ->
      let s, _ = interp_str_expr inp sta se in
      let l1 = match sp with Split -> String.split s | DontSplit -> Cons s Nil end in
      let l2 = interp_list_expr inp sta le_rest in
      l1 ++ l2
    end

  let interp_program inp sta pro =
    try interp_instruction inp sta pro
    with EExit -> () end
end