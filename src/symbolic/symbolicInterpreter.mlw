module Constraints

  type variable
  (** abstract type for variables denoting nodes in the file system *)

  type feature
  (** abstract type for filenames (excluding "." and ".."), named
      "feature" in the tree constraint vocabulary *)

  type clause
  (** abstract type for tree constraints, [IMPORTANT] which are always satisfiable *)

  type path
end

module Filesystem
  use option.Option
  use Constraints

  (** A symbolic filesystem composed by a variable indicating root, constraints, and the
      current working directory `cwd` as feature path. root₀ may refer to the initial root
      variable. When provided it should not be pruned (“quantified over”) during symbolic
      execution of utilities. *)
  type filesystem = {
    root : variable;
    clause : clause;
    root0 : option variable;
  }
end

module Semantics
  use list.List
  use Filesystem
  use Constraints

  (* Instantiate the concrete semantics with the symbolic filesystem *)
  clone export semantics.Semantics with
    type filesystem = filesystem,
    type cwd = list feature,
    val default_cwd = Nil,
    axiom interp_utility_extends_output
end


module SymState

  use list.List
  use Semantics

  (** A symbolic state combines a concrete context and a program state as defined in the
      semantics with a filesystem using feature constraints. *)
  type sym_state 'a = {
    context: context;
    state: state;
    data: 'a (* Used to fiddle additional information through interp_instr': A stdin in pipe and the last result in the loops *)
  }

  let function with_data data =
    fun sta ->
      {sta with data = data}
end

(** The symbolic interpretation of a program results describes multiple possible results
  *)
module Results

  use set.Fset as Fset
  use collection.Collection as Cn
  use list.ListRich as L
  use semantics.Input
  use semantics.Behaviour
  use Semantics
  use SymState

  (** The results of a symbolic execution is a quadruple of sets of symbolic states, where
      each components corresponds to a behaviour. *)
  type t 'a = {
    normal  : Cn.t (sym_state 'a);
    exit    : Cn.t (sym_state 'a);
    return_ : Cn.t (sym_state 'a);
    failure : Cn.t (sym_state 'a);
  }

  (** Helpful for debugging VCs *)
  lemma result_normal: forall normal exit return_ failure: Cn.t (sym_state 'a).
    {normal=normal; exit=exit; return_=return_; failure=failure}.normal = normal

  lemma result_exit: forall normal exit return_ failure: Cn.t (sym_state 'a).
    {normal=normal; exit=exit; return_=return_; failure=failure}.exit = exit

  lemma result_return: forall normal exit return_ failure: Cn.t (sym_state 'a).
    {normal=normal; exit=exit; return_=return_; failure=failure}.return_ = return_

  lemma result_failure: forall normal exit return_ failure: Cn.t (sym_state 'a).
    {normal=normal; exit=exit; return_=return_; failure=failure}.failure = failure

  let constant empty = {
    normal  = Cn.empty;
    exit    = Cn.empty;
    return_ = Cn.empty;
    failure = Cn.empty;
  }

  predicate mem (sta:sym_state 'a) (bhv:behaviour) (rs:t 'a) =
    match bhv with
    | BNormal  -> Cn.mem sta rs.normal
    | BExit    -> Cn.mem sta rs.exit
    | BReturn  -> Cn.mem sta rs.return_
    | BFailure -> Cn.mem sta rs.failure
    end

  let function map (f:sym_state 'a -> sym_state 'b) (res:t 'a) : t 'b
    ensures { forall sta bhv. mem sta bhv res -> mem (f sta) bhv result }
    ensures { forall sta' bhv. mem sta' bhv result -> exists sta. mem sta bhv res /\ sta' = f sta }
  = { normal  = Cn.map f res.normal;
      exit    = Cn.map f res.exit;
      return_ = Cn.map f res.return_;
      failure = Cn.map f res.failure; }

  let function union (res1 res2: t 'a) : t 'a
    ensures { forall sta bhv. mem sta bhv res1 -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv res2 -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> mem sta bhv res1 \/ mem sta bhv res2 }
  = { normal  = Cn.union res1.normal  res2.normal;
      exit    = Cn.union res1.exit    res2.exit;
      return_ = Cn.union res1.return_ res2.return_;
      failure = Cn.union res1.failure res2.failure; }

  lemma union_1: forall sta: sym_state 'a, bhv res1 res2.
    mem sta bhv res1 -> mem sta bhv (union res1 res2)

  lemma union_2: forall sta: sym_state 'a, bhv res1 res2.
    mem sta bhv res2 -> mem sta bhv (union res1 res2)

  let rec flatten_list (l: L.list (t 'a)) : t 'a
    variant { l }
    ensures { forall res sta bhv. L.mem res l -> mem sta bhv res -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> exists res. L.mem res l /\ mem sta bhv res }
  = match l with
    | L.Nil -> empty
    | L.Cons rs l' ->
      union rs (flatten_list l')
    end

  let flatten (c: Cn.t (t 'a)) : t 'a
    ensures { forall res sta bhv. Cn.mem res c -> mem sta bhv res -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> exists res. Cn.mem res c /\ mem sta bhv res }
  = flatten_list (Cn.to_list c)

  let bind_collection (f: 'a -> t 'b) (c: Cn.t 'a) : t 'b
    ensures {
      forall x sta bhv.
      Cn.mem x c ->
      mem sta bhv (f x) ->
      mem sta bhv result
    }
    ensures {
      forall sta bhv.
      mem sta bhv result ->
      exists x.
      Cn.mem x c /\
      mem sta bhv (f x)
    }
  = flatten (Cn.map f c)

  let separate_normal (res:t 'a) : (normal: Cn.t (sym_state 'a), other: t 'a)
    ensures { normal = res.normal }
    ensures { other.normal = Cn.empty }
    ensures { other.exit = res.exit }
    ensures { other.return_ = res.return_ }
    ensures { other.failure = res.failure }
    ensures { forall s. Cn.mem s normal -> Cn.mem s res.normal }
    ensures { forall s bhv. mem s bhv other -> bhv <> BNormal /\ mem s bhv res }
  = res.normal, {res with normal = Cn.empty}

  let function separate_non_failure (res:t 'a) : (Cn.t (sym_state 'a), Cn.t (sym_state 'a))
    = Cn.(union res.normal (union res.exit res.return_)), res.failure

  let function all_states (res:t 'a) : Cn.t (sym_state 'a) =
    Cn.(union res.normal (union res.exit (union res.return_ res.failure)))

  let stas_as_failures (ctx:context) (stas:Cn.t state) : t unit
    ensures { result.normal = Cn.empty }
    ensures { result.exit = Cn.empty }
    ensures { result.return_ = Cn.empty }
    ensures { forall s. Cn.mem s result.failure -> Cn.mem s.state stas /\ s.context=ctx /\ s.data = () }
    ensures { forall s. Cn.mem s stas -> Cn.mem {state=s; context=ctx; data=()} result.failure }
  = let aux sta = {state=sta; context=ctx; data=()} in
    {empty with failure=Cn.map aux stas}

  let function single_behaviour bhv (stas: Cn.t (sym_state 'a)) : t 'a =
    match bhv with
    | BNormal -> {empty with normal=stas}
    | BExit -> {empty with exit=stas}
    | BReturn -> {empty with return_=stas}
    | BFailure -> {empty with failure=stas}
    end

  let function inject (inp: input) (stas: Cn.t (sym_state 'a)) : t 'a
    (* ensures { forall sta bhv. mem sta bhv result <-> Cn.mem sta stas /\ bhv = behaviour inp sta.context.result } *)
    (* ensures { stas = Cn.union result.normal result.exit by Cn.(stas == union result.normal result.exit) } *)
    (* ensures { forall s. Cn.mem s result.normal -> Cn.mem s stas /\ behaviour inp s.context.result = BNormal } *)
    (* ensures { forall s. Cn.mem s result.exit -> Cn.mem s stas /\ behaviour inp s.context.result = BExit } *)
    (* ensures { result.return_ = Cn.empty } *)
    (* ensures { result.failure = Cn.empty } *)
  = let exit, normal = Cn.partition (fun sta -> exit_not_normal inp sta.context.result) stas in
    (* assert { forall sta. Cn.mem sta exit -> exit_not_normal inp sta.context.result = True }; *)
    (* assert { forall sta. Cn.mem sta normal -> exit_not_normal inp sta.context.result = False }; *)
    {empty with normal=normal; exit=exit}
    (* ensures { forall sta bhv. mem sta bhv result -> Cn.mem sta normal \/ Cn.mem sta exit } *)

  lemma mem_inject: forall res: t 'a, sta bhv inp stas.
    res = inject inp stas ->
    (mem sta bhv res <-> Cn.mem sta stas /\ bhv = behaviour inp sta.context.result)

  lemma inject_union: forall res: t 'a, inp stas.
    res = inject inp stas ->
    stas = Cn.union res.normal res.exit by
    Cn.(stas == union res.normal res.exit)

  lemma inject_return_empty: forall res: t 'a, inp stas.
    res = inject inp stas -> res.return_ = Cn.empty

  lemma inject_failure_empty: forall res: t 'a, inp stas.
    res = inject inp stas -> res.failure = Cn.empty

  lemma inject_normal_union_exit: forall inp, stas: Cn.t (sym_state 'a).
    stas = Cn.union (inject inp stas).normal (inject inp stas).exit
    by Cn.(stas == union (inject inp stas).normal (inject inp stas).exit)

  lemma inject_under_condition_normal: forall res: t 'a, inp stas.
    res = inject inp stas ->
    inp.under_condition = True ->
    res.normal = stas
    by Cn.(res.normal == stas)

  lemma inject_under_condition_exit: forall inp, stas: Cn.t (sym_state 'a).
    inp.under_condition = True ->
    (inject inp stas).exit = Cn.empty
    by Cn.((inject inp stas).exit == Cn.empty)

  lemma inject_outside_condition_normal: forall inp, stas: Cn.t (sym_state 'a).
    inp.under_condition = False ->
    (inject inp stas).normal = Cn.filter (fun sta -> sta.context.result) stas
    by Cn.((inject inp stas).normal == filter (fun sta -> sta.context.result) stas)

  lemma inject_outside_condition_exit: forall inp, stas: Cn.t (sym_state 'a).
    inp.under_condition = False ->
    (inject inp stas).exit = Cn.filter (fun sta -> not sta.context.result) stas
    by Cn.((inject inp stas).exit == filter (fun sta -> not sta.context.result) stas)

  lemma inject_map: forall f: sym_state 'a -> sym_state 'b, res inp sta sta' bhv stas.
    res = inject inp (Cn.map f stas) ->
    sta' = f sta ->
    bhv = behaviour inp (f sta).context.result ->
    Cn.mem sta stas ->
    mem sta' bhv res

  lemma inject_map': forall f: sym_state 'a -> sym_state 'b, res inp sta' bhv stas.
    res = inject inp (Cn.map f stas) ->
    mem sta' bhv res ->
    bhv = behaviour inp sta'.context.result /\
    exists sta. Cn.mem sta stas /\ sta' = f sta

  lemma union_inject: forall res: t 'a, inp stas.
    res = inject inp stas ->
    stas = Cn.union res.normal res.exit
    by
    Cn.(stas == union res.normal res.exit)

  lemma mem_union_inject: forall sta: sym_state 'a, bhv inp stas rs.
    mem sta bhv (union (inject inp stas) rs) <->
    ((Cn.mem sta stas /\ bhv = behaviour inp sta.context.result) \/
     mem sta bhv rs)

  lemma mem_union: forall sta bhv, rs1 rs2:t 'a.
    mem sta bhv (union rs1 rs2) <->
    (mem sta bhv rs1 \/ mem sta bhv rs2)

  lemma mem_map: forall sta': sym_state 'b, bhv, rs, f: sym_state 'a -> sym_state 'b.
    mem sta' bhv (map f rs) <->
    exists sta. mem sta bhv rs /\ sta' = f sta

  lemma failure_union: forall rs1 rs2: t 'a.
    failure (union rs1 rs2) = Cn.union (failure rs1) (failure rs2)

  lemma mem_mk_results: forall sta: sym_state 'a, bhv normal exit return_ failure.
    mem sta bhv { normal=normal; exit=exit; return_=return_; failure=failure } <->
    match bhv with
    | BNormal  -> Cn.mem sta normal
    | BExit    -> Cn.mem sta exit
    | BReturn  -> Cn.mem sta return_
    | BFailure -> Cn.mem sta failure
    end

  lemma mem_union_results: forall sta: sym_state 'a, bhv rs1 rs2.
    mem sta bhv (union rs1 rs2) <->
    (match bhv with
     | BNormal  -> Cn.mem sta rs1.normal
     | BExit    -> Cn.mem sta rs1.exit
     | BReturn  -> Cn.mem sta rs1.return_
     | BFailure -> Cn.mem sta rs1.failure
     end \/
     match bhv with
     | BNormal  -> Cn.mem sta rs2.normal
     | BExit    -> Cn.mem sta rs2.exit
     | BReturn  -> Cn.mem sta rs2.return_
     | BFailure -> Cn.mem sta rs2.failure
     end)
end

module Interpreter

  use bool.Bool
  use option.Option
  use int.Int
  use list.List
  use list.ListRich as L
  use set.Fset
  use mystring.String
  use syntax.Syntax
  use auxiliaries.OptionGet
  use collection.Collection as Cn
  use semantics.Behaviour
  use semantics.Input
  use semantics.Config
  use semantics.Buffers
  use semantics.Arguments
  use semantics.Env
  use Constraints
  use import Semantics as S
  use import SymState as St
  use Results as Rs

  (* Implemented in OCaml *)
  val function sym_interp_utility (ctx:utility_context) (id:identifier) (sta:state) : Cn.t (state, bool)
    ensures {
      forall res.
      interp_utility ctx id sta = res <->
      Cn.mem res result
    }

  let rec separate_options_list (sta_opts: list (state, option 'a)) : (results: list (state, 'a), failures: list state)
    variant { sta_opts }
    ensures {
      forall sta x.
      L.mem (sta, x) results <->
      L.mem (sta, Some x) sta_opts
    }
    ensures {
      forall sta.
      L.mem sta failures <->
      L.mem (sta, None) sta_opts
    }
  = match sta_opts with
    | Nil -> Nil, Nil
    | Cons (sta, opt_x) sta_opts' -> 
      let results, failures = separate_options_list sta_opts' in
      match opt_x with
      | Some x -> Cons (sta, x) results, failures
      | None -> results, Cons sta failures
      end
    end

  let separate_options (sta_opts: Cn.t (state, option 'a)) : (results: Cn.t (state, 'a), failures: Cn.t state)
    ensures {
      forall sta x.
      Cn.mem (sta, x) results <->
      Cn.mem (sta, Some x) sta_opts
    }
    ensures {
      forall sta.
      Cn.mem sta failures <->
      Cn.mem (sta, None) sta_opts
    }
  = let results, failures = separate_options_list (Cn.to_list sta_opts) in
    Cn.of_list results, Cn.of_list failures

  let function get_some (o: option 'a) : 'a
    requires { o <> None }
  = match o with
    | Some x -> x
    | None -> absurd
    end

  let rec function size_instr (ins:instruction) : int
    variant { ins }
    ensures { 0 < result }
  = 1 + match ins with
    | IReturn _
    | IExit _
    | IShift _ -> 0
    | IExport _ -> 0
    | INot ins1
    | INoOutput ins1
    | ISubshell ins1 -> size_instr ins1
    | IAssignment _ se  -> size_string_expr se
    | ICallUtility _ le
    | ICallFunction _ le -> size_list_expr le
    | ISequence ins1 ins2
    | IPipe ins1 ins2
    | IWhile ins1 ins2 -> size_instr ins1 + size_instr ins2
    | IForeach _ le ins -> size_list_expr le + size_instr ins
    | IIf ins1 ins2 ins3 -> size_instr ins1 + size_instr ins2 + size_instr ins3
    end
  with function size_list_expr (le:list_expression): int
    variant { le }
    ensures { 0 < result }
  = 1 + match le with
    | Nil -> 0
    | Cons se_sp le' ->
      size_pair se_sp + size_list_expr le'
    end
  with function size_pair (se_sp: (string_expression, split)) : int
    variant { se_sp }
    ensures { 0 < result }
  = let se, _ = se_sp in
    size_string_expr se
  with function size_string_expr (se:string_expression): int
    variant { se }
    ensures { 0 < result }
  = 1 + match se with
    | SLiteral _
    | SVariable _
    | SArgument _ -> 0
    | SSubshell ins -> size_instr ins
    | SConcat se1 se2 -> size_string_expr se1 + size_string_expr se2
    end

  let rec lemma size_string_expr_list_expr (le:list_expression)
    ensures { forall se sp. size_string_expr se < size_list_expr (Cons (se, sp) le) }
  = match le with
    | Nil -> ()
    | Cons _ le' -> size_string_expr_list_expr le'
    end

  let function flip_result sta
    ensures { result.state = sta.state }
    ensures { result.data = sta.data }
    ensures { result.context = with_result (notb sta.context.result) sta.context }
  = let result = notb sta.context.result in
    let context = {sta.context with result=result} in
    {sta with context=context}

  let function reset_output sta sta' =
    let sta'' = {sta'.state with stdout = sta.stdout} in
    {sta' with state = sta''}

  let function assignment_for_str_sta ctx var arg =
    let sta', (str, result) = arg in
    let ctx' = {
      ctx with
      var_env = ctx.var_env[var <- str]';
      result = result;
    }
    in
    {state = sta'; context = ctx'; data = ()}

  let rec interp_instr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (ins:instruction)
    : Rs.t unit
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins, -1 }
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    ensures { (* Over-approximation *)
      forall sta' ctx' bhv.
      eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', bhv) ->
      Rs.mem {state=sta'; context=ctx'; data=()} bhv result
    }
    (* (\* Under-approximation (->) and over-approximation (<-) *\) *)
    (* ensures { *)
    (*   forall bhv sta'. *)
    (*   Rs.mem sta' bhv result <-> *)
    (*   eval_instruction stk (cnf, inp, ctx, sta) ins *)
    (*     (sta'.state, sta'.context, bhv) *)
    (* } *)
  = match ins with

    | INot ins1 ->
      let res = interp_instr stk cnf {inp with under_condition=True} ctx sta ins1 in
      Rs.({
          normal = Cn.map flip_result res.normal;
          return_ = Cn.map flip_result res.return_;
          exit = res.exit;
          failure = res.failure;
        })
      ensures {
        forall sta' ctx' bhv.
        eval_instruction stk (cnf, {inp with under_condition=True}, ctx, sta) ins1 (sta', ctx', bhv) ->
        match bhv with
        | BNormal | BReturn -> Rs.mem {state=sta'; context=with_result (notb ctx'.result) ctx'; data=()} bhv result
        | BExit | BFailure -> Rs.mem {state=sta'; context=ctx'; data=()} bhv result
        end
      }

    | IAssignment var se ->
      let str_stas, str_stas_failure =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se)
      in
      let str_stas_failure = Rs.stas_as_failures ctx str_stas_failure in
      let res =
        Rs.inject inp
          (Cn.map (fun arg -> assignment_for_str_sta ctx var arg) str_stas)
      in
      Rs.(union res str_stas_failure)
      ensures {
        forall sta'.
        eval_str_expr stk True (cnf, inp, ctx, sta) se (sta', None) ->
        Cn.mem {state=sta'; context=ctx; data=()} result.Rs.failure
      }

    | IExport id ->
      let sta' =
        let ctx' =
          let var_val = {ctx.var_env[id] with exported=True} in
          let var_env' = ctx.var_env[id <- var_val] in
          {ctx with var_env = var_env'; result = True}
        in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with normal = Cn.singleton sta'})

    | ISequence ins1 ins2 ->
      let res1_normal, res1_other =
        Rs.separate_normal
          (interp_instr stk cnf inp ctx sta ins1)
      in
      let res2 = interp_instr' stk cnf inp res1_normal ins2 in
      Rs.union res2 res1_other

    | ISubshell ins ->
      let stas, stas_failure =
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta ins)
      in
      assert {
        forall sta' ctx' bhv.
        bhv <> BFailure ->
        eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', bhv) ->
        Cn.mem {state=sta'; context=ctx'; data=()} stas
      };
      let stas' =
        let aux sta =
          let ctx' = {ctx with result = sta.context.result} in
          {state=sta.state; context=ctx'; data=()}
        in
        Cn.map aux stas
      in
      let old_ctx_with_res sta = {sta with context=with_result sta.context.result ctx} in
      Rs.(union
           (inject inp stas')
           {empty with failure=Cn.map old_ctx_with_res stas_failure})
      ensures {
        forall sta' ctx'.
        eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', BFailure) ->
        Rs.mem {state=sta'; context=with_result ctx'.result ctx; data=()} BFailure result
      }

    | INoOutput ins ->
      Rs.map (reset_output sta)
        (interp_instr stk cnf inp ctx sta ins)

    | IIf ins1 ins2 ins3 ->
      let res1_normal, res1_other =
        Rs.separate_normal
          (interp_instr stk cnf {inp with under_condition=True} ctx sta ins1)
      in
      let res2 =
        let res1_true, res1_false =
          Cn.partition
            (fun sta -> sta.context.result)
            res1_normal
        in
        Rs.union
          (interp_instr' stk cnf inp res1_true ins2)
          (interp_instr' stk cnf inp res1_false ins3)
      in
      Rs.union res2 res1_other

    | ICallUtility id le ->
      let res, res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      let res' =
        let function aux arg =
          let sta', args = arg in
          sym_interp_utility (ctx.cwd, filter_var_env ctx.var_env, args) id sta'
        in
        Cn.bind aux res
      in
      let res'' =
        let function aux arg =
          let sta'', b = arg in
          {state=sta''; context=with_result b ctx; data=()}
        in
        Cn.map aux res'
      in
      let res''' = Rs.inject inp res'' in
      let res_failures' = Rs.stas_as_failures ctx res_failures in
      Rs.union res''' res_failures'
      ensures {
        forall sta' ss sta'' b.
        eval_list_expr stk (cnf, inp, ctx, sta) le (sta', Some ss) ->
        (sta'', b) = interp_utility (ctx.cwd, filter_var_env ctx.var_env, ss) id sta' ->
        Rs.mem {state=sta''; context=with_result b ctx; data=()} (behaviour inp b) result
        by Rs.mem {state=sta''; context=with_result b ctx; data=()} (behaviour inp b) res'''
      }

    | ICallFunction id le ->
      let arg_res, arg_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      assert {
        forall sta1 args.
        eval_list_expr stk (cnf, inp, ctx, sta) le (sta1, Some args) ->
        Cn.mem (sta1, args) arg_res
      };
      let res =
        match ctx.func_env[id] with
        | Some ins -> (* Function defined as `ins` *)
            if stk = get_some cnf.stack_size then (* Stack overflow *)
              let aux arg =
                let sta', _ = arg in
                {state=sta'; context=ctx; data=()}
              in
              Rs.({empty with failure = Cn.map aux arg_res})
              ensures {
                forall sta1 args ins.
                eval_list_expr stk (cnf, inp, ctx, sta) le (sta1, Some args) ->
                ctx.func_env[id] = Some ins ->
                match cnf.stack_size with Some n -> n = stk | None -> false end ->
                Rs.mem {state=sta1; context=ctx; data=()} BFailure result
              }
            else (* Execute function *)
              let res2 =
                let function aux (arg: (state, list string))  =
                  let sta1, args = arg in
                  let inp1 = {inp with argument0 = identifier_to_string id} in
                  let ctx1 = {ctx with arguments = args} in
                  interp_instr (stk+1) cnf inp1 ctx1 sta1 ins
                in
                Rs.bind_collection aux arg_res
                ensures {
                  forall sta1 args ins sta2 ctx2 bhv2.
                  eval_list_expr stk (cnf, inp, ctx, sta) le (sta1, Some args) ->
                  ctx.func_env[id] = Some ins ->
                  match cnf.stack_size with Some n -> n <> stk | None -> true end ->
                  let inp1 = {inp with argument0=identifier_to_string id} in
                  let ctx1 = {ctx with arguments=args} in
                  eval_instruction (stk+1) (cnf, inp1, ctx1, sta1) ins (sta2, ctx2, bhv2) ->
                  Rs.mem {state=sta2; context=ctx2; data=()} bhv2 result
                }
              in
              let res2' =
                let function aux (sta2: sym_state unit) =
                  {state=sta2.state; context=with_result sta2.context.result ctx; data=()}
                in
                Rs.map aux res2
                ensures {
                  forall sta1 args ins sta2 ctx2 bhv2.
                  eval_list_expr stk (cnf, inp, ctx, sta) le (sta1, Some args) ->
                  ctx.func_env[id] = Some ins ->
                  match cnf.stack_size with Some n -> n <> stk | None -> true end ->
                  let inp1 = {inp with argument0=identifier_to_string id} in
                  let ctx1 = {ctx with arguments=args} in
                  eval_instruction (stk+1) (cnf, inp1, ctx1, sta1) ins (sta2, ctx2, bhv2) ->
                  Rs.mem {state=sta2; context=with_result ctx2.result ctx; data=()} bhv2 result
                }
              in
              Rs.({res2' with normal=Cn.union res2'.normal res2'.return_; return_=Cn.empty})
              ensures {
                forall sta1 args ins sta2 ctx2 bhv2.
                eval_list_expr stk (cnf, inp, ctx, sta) le (sta1, Some args) ->
                ctx.func_env[id] = Some ins ->
                match cnf.stack_size with Some n -> n <> stk | None -> true end ->
                let inp1 = {inp with argument0=identifier_to_string id} in
                let ctx1 = {ctx with arguments=args} in
                eval_instruction (stk+1) (cnf, inp1, ctx1, sta1) ins (sta2, ctx2, bhv2) ->
                let bhv' = match bhv2 with BNormal | BReturn -> BNormal | BExit -> BExit | BFailure -> BFailure end in
                let ctx' = with_result ctx2.result ctx in
                Rs.mem {state=sta2; context=ctx'; data=()} bhv' result
              }
        | None -> (* Undefined function *)
            let arg_res' =
              let function aux (arg: (state, list string)) =
                let sta', _ = arg in
                {state=sta'; context=with_result False ctx; data=()}
              in
              Cn.map aux arg_res
              ensures {
                forall sta' ss.
                eval_list_expr stk (cnf, inp, ctx, sta) le (sta', Some ss) ->
                ctx.func_env[id] = None ->
                Cn.mem {state=sta'; context=with_result False ctx; data=()} result
                by Cn.mem (sta', ss) arg_res
              }
            in
            Rs.single_behaviour (behaviour inp False) arg_res'
            ensures {
              forall sta' ss.
              eval_list_expr stk (cnf, inp, ctx, sta) le (sta', Some ss) ->
              ctx.func_env[id] = None ->
              Rs.mem {state=sta'; context=with_result False ctx; data=()} (behaviour inp False) result
            }
        end
      in
      let res_failures = Rs.stas_as_failures ctx arg_res_failures in
      Rs.union res res_failures

    | IShift bn ->
      match shift_arguments (option_get (mk_nat 1) bn).nat ctx.arguments with
      | Some args ->
        let ctx' = {ctx with result = True; arguments = args} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.({empty with normal = Cn.singleton sta'})
      | None ->
        let ctx' = {ctx with result = False} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.inject inp (Cn.singleton sta')
      end

    | IForeach id le ins ->
      let lst_res, lst_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      (* Run interpretation of foreach in one state *)
      let rec interp_foreach (b:bool) (ctx:context) (sta:state) (ss:list string) : Rs.t bool
        variant { ss }
      = match ss with
        | Nil ->
          Rs.({empty with normal=Cn.singleton {state=sta; context=ctx; data=b}})
        | Cons s ss' ->
          let res1_normal, res1_abort =
            let ctx' = {ctx with var_env = ctx.var_env[id <- s]'} in
            Rs.separate_normal
              (interp_instr stk cnf inp ctx' sta ins)
          in
          let for_normal sta1 = interp_foreach sta1.context.result sta1.context sta1.state ss' in
          let for_abort sta  = with_data sta.context.result sta in
          Rs.(union
                (bind_collection for_normal res1_normal)
                (map for_abort res1_abort))
        end
      in
      (* Execute foreach loop on a result from interp_list_expr *)
      let interp_foreach' arg =
        let sta', ss = arg in
        interp_foreach True ctx sta' ss
      in
      (* Move data to result *)
      let set_result sta'' =
        let ctx'' = with_result sta''.data sta''.context in
        with_data () {sta'' with context = ctx'' }
      in
      Rs.(union
           (map set_result
             (bind_collection interp_foreach' lst_res))
           (stas_as_failures ctx lst_res_failures))

    | IWhile ins1 ins2 ->
      let loop_limit = match cnf.loop_limit with Some n -> n | None -> absurd end in
      let rec interp_while ctr (stas: Cn.t (sym_state bool)) : Rs.t unit
        variant { get_some cnf.loop_limit - ctr }
        requires { ctr <= get_some cnf.loop_limit }
      = if ctr = loop_limit then
          Rs.(map (with_data ()) {empty with failure=stas})
        else
          let res1_normal, res1_abort =
            Rs.separate_normal
              (interp_instr' stk cnf {inp with under_condition=True} stas ins1)
          in
          let res1_true, res1_false =
            Cn.partition (fun sta -> sta.context.result) res1_normal
          in
          let res2_normal, res2_abort =
            Rs.separate_normal
              (interp_instr' stk cnf inp res1_true ins2)
          in
          let res3 = interp_while (ctr+1) res2_normal in
          let others =
            let res1_false' = Rs.({empty with normal=res1_false}) in
            Rs.(map (with_data ())
                 (union res2_abort
                  (union res1_abort res1_false')))
          in
          Rs.union res3 others
      in
      interp_while 0 (Cn.singleton ({state=sta; context=ctx; data=True}))

    | IPipe ins1 ins2 ->
      let stas1, stas1_failure =
        let sta' = {sta with stdout = Stdout.empty} in
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta' ins1)
      in
      let res2 =
        let stas1' =
          let set_stdin_stdout sta1 =
            let sta' = {sta1.state with stdout = sta.stdout; stdin = Stdout.to_stdin sta1.state.stdout} in
            {state=sta'; context=ctx; data=sta1.state.stdin}
          in
          Cn.map set_stdin_stdout stas1
        in
        interp_instr' stk cnf inp stas1' ins2
      in
      let revise sta2 =
        let sta2' = {sta2.state with stdin=sta2.data} in
        let ctx' = {ctx with result=sta2.context.result} in
        {state=sta2'; context=ctx'; data=()}
      in
      Rs.(union (map revise res2) {empty with failure = stas1_failure})

    | IExit code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta = {state=sta; context={ctx with result=r}; data=()} in
      Rs.({empty with exit = Cn.singleton sta})

    | IReturn code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with return_ = Cn.singleton sta})
    end

  with interp_instr' (stk:int) (cnf:config) (inp:input) (stas: Cn.t (sym_state 'a)) (ins:instruction) : Rs.t 'a
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins, Cn.size stas }
    ensures { (* Over-approximation *)
      forall sta sta' ctx' bhv.
      Cn.mem sta stas ->
      eval_instruction stk (cnf, inp, sta.context, sta.state) ins (sta', ctx', bhv) ->
      Rs.mem {state=sta'; context=ctx'; data=sta.data} bhv result
    }
  = let interp_instr_with_data sta =
      ensures {
        forall sta' ctx' bhv.
        eval_instruction stk (cnf, inp, sta.context, sta.state) ins (sta', ctx', bhv) ->
        Rs.mem {state=sta'; context=ctx'; data=sta.data} bhv result
      }
      Rs.map (with_data sta.data)
        (interp_instr stk cnf inp sta.context sta.state ins)
    in
    Rs.bind_collection interp_instr_with_data stas

  with interp_str_expr (stk:int) (b:bool) (cnf:config) (inp:input) (ctx:context) (sta:state) (se:string_expression)
    : Cn.t (state, option (string, bool))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_string_expr se, -1 }
    ensures { (* Over-approximation *)
      forall sta' res.
      eval_str_expr stk b (cnf, inp, ctx, sta) se (sta', res) ->
      Cn.mem (sta', res) result
    }
  = match se with
    | SLiteral str ->
      Cn.singleton (sta, Some (str, b))
    | SVariable var ->
      let str = ctx.var_env[var]' in
      Cn.singleton (sta, Some (str, b))
    | SArgument n ->
      let str = nth_argument (Cons inp.argument0 ctx.arguments) n.nat in
      Cn.singleton (sta, Some (str, b))
    | SSubshell ins ->
      let res, stas_failure =
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx {sta with stdout=Stdout.empty} ins)
      in
      let res' =
        let for_res (sta1:sym_state unit)
        = let str = Stdout.to_string sta1.state.stdout in
          let sta1' = {sta1.state with stdout=sta.stdout} in
          let b' = sta1.context.result in
          sta1', Some (str, b')
        in
        Cn.map for_res res
      in
      let res_failure' =
        Cn.map (fun sta1 -> {sta1.state with stdout=sta.stdout}, None) stas_failure
      in
      Cn.union res' res_failure'
      ensures {
        forall sta1 ctx1.
        eval_instruction stk (cnf, inp, ctx, {sta with stdout=Stdout.empty}) ins (sta1, ctx1, BFailure) ->
        Cn.mem ({sta1 with stdout = sta.stdout}, None) result
        by Cn.mem ({sta1 with stdout = sta.stdout}, None) res_failure'
      }
      ensures {
        forall sta1 ctx1 bhv1.
        bhv1 <> BFailure ->
        eval_instruction stk (cnf, inp, ctx, {sta with stdout=Stdout.empty}) ins (sta1, ctx1, bhv1) ->
        Cn.mem ({sta1 with stdout = sta.stdout}, Some (Stdout.to_string sta1.stdout, ctx1.result)) result
        by Cn.mem ({sta1 with stdout = sta.stdout}, Some (Stdout.to_string sta1.stdout, ctx1.result)) res'
      }
    | SConcat se1 se2 ->
      let res1, res1_failure =
        separate_options
          (interp_str_expr stk b cnf inp ctx sta se1)
      in
      let res1' =
        let for_res1 arg
          ensures {
            let sta1, (str1, b1) = arg in
            forall sta2.
            eval_str_expr stk b (cnf, inp, ctx, sta) se1 (sta1, Some (str1, b1)) ->
            eval_str_expr stk b1 (cnf, inp, ctx, sta1) se2 (sta2, None) ->
            Cn.mem (sta2, None) result
          }
          ensures {
            let sta1, (str1, b1) = arg in
            forall sta2 str2 b2.
            eval_str_expr stk b (cnf, inp, ctx, sta) se1 (sta1, Some (str1, b1)) ->
            eval_str_expr stk b1 (cnf, inp, ctx, sta1) se2 (sta2, Some (str2, b2)) ->
            Cn.mem (sta2, Some (str1^str2, b2)) result
          }
        = let sta1, (str1, b1) = arg in
          let res2, res2_failure =
            separate_options
              (interp_str_expr stk b1 cnf inp ctx sta1 se2)
          in
          let res2_failure' =
            Cn.map (fun sta -> sta, None) res2_failure
          in
          let res2' =
            let for_res2 arg2 =
              let sta2, (str2, b2) = arg2 in
              sta2, Some (str1^str2, b2)
            in
            Cn.map for_res2 res2
          in
          Cn.(union res2' res2_failure')
        in
        Cn.bind for_res1 res1
      in
      let res1_failure' =
        Cn.map (fun sta -> sta, None) res1_failure
      in
      Cn.(union res1' res1_failure')
    end

  with interp_list_expr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (le:list_expression)
    : Cn.t (state, option (list string))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_list_expr le, -1 }
    ensures { (* Over-approximation *)
      forall sta' res.
      eval_list_expr stk (cnf, inp, ctx, sta) le (sta', res) ->
      Cn.mem (sta', res) result
    }
  = match le with
    | Nil ->
      Cn.singleton (sta, Some Nil)
    | Cons (se, sp) le' ->
      let str_res1, str_res1_failures =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se : Cn.t (state, option (string, bool)))
      in
      let res2 =
        let for_sta_str (arg: (state, (string, bool)))
          ensures {
            let sta1, (str1, b1) = arg in
            forall sta2.
            eval_str_expr stk True (cnf, inp, ctx, sta) se (sta1, Some (str1, b1)) ->
            eval_list_expr stk (cnf, inp, ctx, sta1) le' (sta2, None) ->
            Cn.mem (sta2, None) result
          }
          ensures {
            let sta1, (str1, b1) = arg in
            forall sta2 l2.
            eval_str_expr stk True (cnf, inp, ctx, sta) se (sta1, Some (str1, b1)) ->
            eval_list_expr stk (cnf, inp, ctx, sta1) le' (sta2, Some l2) ->
            Cn.mem (sta2, Some L.(split sp str1++l2)) result
          }
        = let sta1, (str1, _) = arg in
          let lst_res2: Cn.t (state, list string), lst_res2_failures: Cn.t state =
            separate_options
              (interp_list_expr stk cnf inp ctx sta1 le')
          in
          let lst_res2' =
            Cn.map (fun arg -> let sta2, strs2 = arg in sta2, Some L.(split sp str1++strs2)) lst_res2
          in
          let lst_res2_failures' =
            Cn.map (fun sta -> sta, None) lst_res2_failures
          in
          Cn.(union lst_res2' lst_res2_failures')
        in
        Cn.bind for_sta_str str_res1
      in
      let str_res1_failures' =
        Cn.map (fun sta -> sta, None) str_res1_failures
      in
      Cn.(union res2 str_res1_failures')
    end

  let rec interp_function_definitions (fenv:func_env) (defs:list function_definition)
    variant { defs }
  = match defs with
    | Nil -> fenv
    | Cons (id, instr) defs' ->
      interp_function_definitions fenv[id <- Some instr]  defs'
    end

  let function only_states_with_result (res: bool) (stas: Cn.t (sym_state unit)) : Cn.t state =
    Cn.(map (fun sta -> sta.state)
          (filter (fun sta -> notb (xorb res sta.context.result))
          stas))

  let interp_program loop_limit stack_size inp stas pro : (Cn.t state, Cn.t state, Cn.t state)
    requires { 0 <= loop_limit }
    requires { 0 <= stack_size }
  = let stas, stas_failure =
      let cnf = { loop_limit = Some loop_limit; stack_size = Some stack_size } in
      let stas =
        let aux sta =
          let fenv = interp_function_definitions sta.context.func_env pro.function_definitions in
          {sta with context={sta.context with func_env = fenv}}
        in
        Cn.map aux stas
      in
      Rs.separate_non_failure
        (interp_instr' 0 cnf inp stas pro.instruction)
    in
    (only_states_with_result True stas,
     only_states_with_result False stas,
     Cn.map (fun sta -> sta.state) stas_failure)
end