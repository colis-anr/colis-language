module Constraints

  type variable
  (** abstract type for variables denoting nodes in the file system *)

  type feature
  (** abstract type for filenames (excluding "." and ".."), named
      "feature" in the tree constraint vocabulary *)

  type clause
  (** abstract type for tree constraints, [IMPORTANT] which are always satisfiable *)

  type path
end

module Filesystem
  use option.Option
  use Constraints

  (** A symbolic filesystem composed by a variable indicating root, constraints, and the
      current working directory `cwd` as feature path. root₀ may refer to the initial root
      variable. When provided it should not be pruned (“quantified over”) during symbolic
      execution of utilities. *)
  type filesystem = {
    root : variable;
    clause : clause;
    root0 : option variable;
  }
end

module Semantics
  use list.List
  use Filesystem
  use Constraints

  (* Instantiate the concrete semantics with the symbolic filesystem *)
  clone export semantics.Semantics with
    type filesystem = filesystem,
    type cwd = list feature,
    val default_cwd = Nil,
    axiom interp_utility_extends_output
end


module SymState

  use list.List
  use Semantics

  (** A symbolic state combines a concrete context and a program state as defined in the
      semantics with a filesystem using feature constraints. *)
  type sym_state 'a = {
    context: context;
    state: state;
    data: 'a (* Used to fiddle additional information through interp_instr': A stdin in pipe and the last result in the loops *)
  }

  let function with_data data =
    fun sta ->
      {sta with data = data}
end

(** The symbolic interpretation of a program results describes multiple possible results
  *)
module Results

  use set.Fset as Fset
  use collection.Collection as Cn
  use list.ListRich as L
  use semantics.Input
  use semantics.Behaviour
  use Semantics
  use SymState

  (** The results of a symbolic execution is a quadruple of sets of symbolic states, where
      each components corresponds to a behaviour. *)
  type t 'a = {
    normal  : Cn.t (sym_state 'a);
    exit    : Cn.t (sym_state 'a);
    return_ : Cn.t (sym_state 'a);
    failure : Cn.t (sym_state 'a);
  }

  let constant empty = {
    normal  = Cn.empty;
    exit    = Cn.empty;
    return_ = Cn.empty;
    failure = Cn.empty;
  }

  predicate mem (sta:sym_state 'a) (bhv:behaviour) (rs:t 'a) =
    match bhv with
    | BNormal  -> Cn.mem sta rs.normal
    | BExit    -> Cn.mem sta rs.exit
    | BReturn  -> Cn.mem sta rs.return_
    | BFailure -> Cn.mem sta rs.failure
    end

  let function map (f:sym_state 'a -> sym_state 'b) (res:t 'a) : t 'b
    ensures { forall sta bhv. mem sta bhv res -> mem (f sta) bhv result }
    ensures { forall sta' bhv. mem sta' bhv result -> exists sta. mem sta bhv res /\ sta' = f sta }
  = { normal  = Cn.map f res.normal;
      exit    = Cn.map f res.exit;
      return_ = Cn.map f res.return_;
      failure = Cn.map f res.failure; }

  let function union (res1 res2: t 'a) : t 'a
    ensures { forall sta bhv. mem sta bhv res1 -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv res2 -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> mem sta bhv res1 \/ mem sta bhv res2 }
  = { normal  = Cn.union res1.normal  res2.normal;
      exit    = Cn.union res1.exit    res2.exit;
      return_ = Cn.union res1.return_ res2.return_;
      failure = Cn.union res1.failure res2.failure; }

  let rec flatten_list (l: L.list (t 'a)) : t 'a
    variant { l }
    ensures { forall res sta bhv. L.mem res l -> mem sta bhv res -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> exists res. L.mem res l /\ mem sta bhv res }
  = match l with
    | L.Nil -> empty
    | L.Cons rs l' ->
      union rs (flatten_list l')
    end

  let flatten (c: Cn.t (t 'a)) : t 'a
    ensures { forall res sta bhv. Cn.mem res c -> mem sta bhv res -> mem sta bhv result }
    ensures { forall sta bhv. mem sta bhv result -> exists res. Cn.mem res c /\ mem sta bhv res }
  = flatten_list (Cn.to_list c)

  let bind_collection (f: 'a -> t 'b) (c: Cn.t 'a) : t 'b
    ensures {
      forall x sta bhv.
      Cn.mem x c ->
      mem sta bhv (f x) ->
      mem sta bhv result
    }
    ensures {
      forall sta bhv.
      mem sta bhv result ->
      exists x.
      Cn.mem x c /\
      mem sta bhv (f x)
    }
  = flatten (Cn.map f c)

  let separate_normal (res:t 'a) : (normal: Cn.t (sym_state 'a), other: t 'a)
    ensures { normal = res.normal }
    ensures { other.normal = Cn.empty }
    ensures { other.exit = res.exit }
    ensures { other.return_ = res.return_ }
    ensures { other.failure = res.failure }
    ensures { forall s. Cn.mem s normal -> Cn.mem s res.normal }
    ensures { forall s bhv. mem s bhv other -> bhv <> BNormal /\ mem s bhv res }
  = res.normal, {res with normal = Cn.empty}

  let function separate_non_failure (res:t 'a) : (Cn.t (sym_state 'a), Cn.t (sym_state 'a))
    = Cn.(union res.normal (union res.exit res.return_)), res.failure

  let function all_states (res:t 'a) : Cn.t (sym_state 'a) =
    Cn.(union res.normal (union res.exit (union res.return_ res.failure)))

  let stas_as_failures (ctx:context) (stas:Cn.t state) : t unit
    ensures { result.normal = Cn.empty }
    ensures { result.exit = Cn.empty }
    ensures { result.return_ = Cn.empty }
    ensures { forall s. Cn.mem s result.failure -> Cn.mem s.state stas /\ s.context=ctx /\ s.data = () }
    ensures { forall s. Cn.mem s stas -> Cn.mem {state=s; context=ctx; data=()} result.failure }
  = let aux sta = {state=sta; context=ctx; data=()} in
    {empty with failure=Cn.map aux stas}

  let function is_state_behaviour (inp:input) (bhv:behaviour) : sym_state 'a -> bool = fun sta ->
    eq_behaviour bhv
      (behaviour inp sta.context.result)

  lemma state_behaviour_normal_exit: forall inp bhv, sta: sym_state 'a.
    is_state_behaviour inp bhv sta = True ->
    (bhv <> BReturn /\ bhv <> BFailure)

  let function inject (inp:input) (stas:Cn.t (sym_state 'a)) : t 'a
    ensures { stas = Cn.union result.normal result.exit by Cn.(stas == union result.normal result.exit) }
    ensures { forall s. Cn.mem s result.normal -> Cn.mem s stas /\ behaviour inp s.context.result = BNormal }
    ensures { forall s. Cn.mem s result.exit -> Cn.mem s stas /\ behaviour inp s.context.result = BExit }
    ensures { result.return_ = Cn.empty }
    ensures { result.failure = Cn.empty }
  = {normal = Cn.filter (is_state_behaviour inp BNormal) stas;
     exit = Cn.filter (is_state_behaviour inp BExit) stas;
     return_ = Cn.empty;
     failure = Cn.empty}

  lemma mem_union: forall sta bhv, rs1 rs2:t 'a.
    mem sta bhv (union rs1 rs2) <->
    (mem sta bhv rs1 \/ mem sta bhv rs2)

  lemma mem_map: forall sta': sym_state 'b, bhv, rs, f: sym_state 'a -> sym_state 'b.
    mem sta' bhv (map f rs) <->
    exists sta. mem sta bhv rs /\ sta' = f sta

  lemma failure_union: forall rs1 rs2: t 'a.
    failure (union rs1 rs2) = Cn.union (failure rs1) (failure rs2)

  lemma mem_mk_results: forall sta: sym_state 'a, bhv normal exit return_ failure.
    mem sta bhv { normal=normal; exit=exit; return_=return_; failure=failure } <->
    match bhv with
    | BNormal  -> Cn.mem sta normal
    | BExit    -> Cn.mem sta exit
    | BReturn  -> Cn.mem sta return_
    | BFailure -> Cn.mem sta failure
    end

  lemma mem_union_results: forall sta: sym_state 'a, bhv rs1 rs2.
    mem sta bhv (union rs1 rs2) <->
    (match bhv with
     | BNormal  -> Cn.mem sta rs1.normal
     | BExit    -> Cn.mem sta rs1.exit
     | BReturn  -> Cn.mem sta rs1.return_
     | BFailure -> Cn.mem sta rs1.failure
     end \/
     match bhv with
     | BNormal  -> Cn.mem sta rs2.normal
     | BExit    -> Cn.mem sta rs2.exit
     | BReturn  -> Cn.mem sta rs2.return_
     | BFailure -> Cn.mem sta rs2.failure
     end)

  lemma mem_inject: forall sta: sym_state 'a, bhv inp stas.
    mem sta bhv (inject inp stas) <->
    Cn.mem sta stas /\ is_state_behaviour inp bhv sta

  lemma mem_union_inject: forall sta: sym_state 'a, bhv inp stas rs.
    mem sta bhv (union (inject inp stas) rs) <->
    ((Cn.mem sta stas /\ is_state_behaviour inp bhv sta) \/
     mem sta bhv rs)
end

module Interpreter

  use bool.Bool
  use option.Option
  use int.Int
  use list.List
  use list.ListRich as L
  use set.Fset
  use mystring.String
  use syntax.Syntax
  use auxiliaries.OptionGet
  use collection.Collection as Cn
  use semantics.Behaviour
  use semantics.Input
  use semantics.Config
  use semantics.Buffers
  use semantics.Arguments
  use semantics.Env
  use Constraints
  use import Semantics as S
  use import SymState as St
  use Results as Rs

  (* Implemented in OCaml *)
  val function sym_interp_utility (id:identifier) (cwd:list feature) (var_env:env string) (args:list string) (sta:state) : Cn.t (state, bool)
    ensures {
      forall res.
      interp_utility var_env sta id args = res <->
      Cn.mem res result
    }

  let rec separate_options_list (sta_opts: list (state, option 'a)) : (results: list (state, 'a), failures: list state)
    variant { sta_opts }
    ensures {
      forall sta x.
      L.mem (sta, x) results <->
      L.mem (sta, Some x) sta_opts
    }
    ensures {
      forall sta.
      L.mem sta failures <->
      L.mem (sta, None) sta_opts
    }
  = match sta_opts with
    | Nil -> Nil, Nil
    | Cons (sta, opt_x) sta_opts' -> 
      let results, failures = separate_options_list sta_opts' in
      match opt_x with
      | Some x -> Cons (sta, x) results, failures
      | None -> results, Cons sta failures
      end
    end

  let separate_options (sta_opts: Cn.t (state, option 'a)) : (results: Cn.t (state, 'a), failures: Cn.t state)
    ensures {
      forall sta x.
      Cn.mem (sta, x) results <->
      Cn.mem (sta, Some x) sta_opts
    }
    ensures {
      forall sta.
      Cn.mem sta failures <->
      Cn.mem (sta, None) sta_opts
    }
  = let results, failures = separate_options_list (Cn.to_list sta_opts) in
    Cn.of_list results, Cn.of_list failures

  let function get_some (o: option 'a) : 'a
    requires { o <> None }
  = match o with
    | Some x -> x
    | None -> absurd
    end

  let rec function size_instr (ins:instruction) : int
    variant { ins }
    ensures { 0 < result }
  = 1 + match ins with
    | IReturn _
    | IExit _
    | IShift _ -> 0
    | IExport _ -> 0
    | INot ins1
    | INoOutput ins1
    | ISubshell ins1 -> size_instr ins1
    | IAssignment _ se  -> size_string_expr se
    | ICallUtility _ le
    | ICallFunction _ le -> size_list_expr le
    | ISequence ins1 ins2
    | IPipe ins1 ins2
    | IWhile ins1 ins2 -> size_instr ins1 + size_instr ins2
    | IForeach _ le ins -> size_list_expr le + size_instr ins
    | IIf ins1 ins2 ins3 -> size_instr ins1 + size_instr ins2 + size_instr ins3
    end
  with function size_list_expr (le:list_expression): int
    variant { le }
    ensures { 0 < result }
  = 1 + match le with
    | Nil -> 0
    | Cons se_sp le' ->
      size_pair se_sp + size_list_expr le'
    end
  with function size_pair (se_sp: (string_expression, split)) : int
    variant { se_sp }
    ensures { 0 < result }
  = let se, _ = se_sp in
    size_string_expr se
  with function size_string_expr (se:string_expression): int
    variant { se }
    ensures { 0 < result }
  = 1 + match se with
    | SLiteral _
    | SVariable _
    | SArgument _ -> 0
    | SSubshell ins -> size_instr ins
    | SConcat se1 se2 -> size_string_expr se1 + size_string_expr se2
    end

  let rec lemma size_string_expr_list_expr (le:list_expression)
    ensures { forall se sp. size_string_expr se < size_list_expr (Cons (se, sp) le) }
  = match le with
    | Nil -> ()
    | Cons _ le' -> size_string_expr_list_expr le'
    end

  let function flip_result sta
    ensures { result.state = sta.state }
    ensures { result.data = sta.data }
    ensures { result.context = with_result (notb sta.context.result) sta.context }
  = let result = notb sta.context.result in
    let context = {sta.context with result=result} in
    {sta with context=context}

  let function reset_output sta sta' =
    let sta'' = {sta'.state with stdout = sta.stdout} in
    {sta' with
      state = sta''}

  let function state_split_str sp arg =
    let sta, (str, _:bool) = arg in
    sta, split sp str

  let function state_concat strs1 arg =
    let sta2, strs2 = arg in
    sta2, Some L.(strs1++strs2)

  let function assignment_for_str_sta ctx var arg =
    let sta', (str, result) = arg in
    let ctx' = {
      ctx with
      var_env = ctx.var_env[var <- str]';
      result = result;
    }
    in
    {state = sta'; context = ctx'; data = ()}

  let rec interp_instr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (ins:instruction)
    : Rs.t unit
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins }
    ensures { (* Over-approximation *)
      forall sta' ctx' bhv.
      eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', bhv) ->
      Rs.mem {state=sta'; context=ctx'; data=()} bhv result
    }
    (* (\* Under-approximation (->) and over-approximation (<-) *\) *)
    (* ensures { *)
    (*   forall bhv sta'. *)
    (*   Rs.mem sta' bhv result <-> *)
    (*   eval_instruction stk (cnf, inp, ctx, sta) ins *)
    (*     (sta'.state, sta'.context, bhv) *)
    (* } *)
  = match ins with

    | INot ins1 ->
      let res = interp_instr stk cnf {inp with under_condition=True} ctx sta ins1 in
      Rs.({
          normal = Cn.map flip_result res.normal;
          return_ = Cn.map flip_result res.return_;
          exit = res.exit;
          failure = res.failure;
        })
      ensures {
        forall sta' ctx' bhv.
        eval_instruction stk (cnf, {inp with under_condition=True}, ctx, sta) ins1 (sta', ctx', bhv) ->
        match bhv with
        | BNormal | BReturn -> Rs.mem {state=sta'; context=with_result (notb ctx'.result) ctx'; data=()} bhv result
        | BExit | BFailure -> Rs.mem {state=sta'; context=ctx'; data=()} bhv result
        end
      }

    | IAssignment var se ->
      let str_stas, str_stas_failure =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se)
      in
      let str_stas_failure = Rs.stas_as_failures ctx str_stas_failure in
      let res =
        Rs.inject inp
          (Cn.map (fun arg -> assignment_for_str_sta ctx var arg) str_stas)
      in
      Rs.(union res str_stas_failure)
      ensures {
        forall sta'.
        eval_str_expr stk True (cnf, inp, ctx, sta) se (sta', None) ->
        Cn.mem {state=sta'; context=ctx; data=()} result.Rs.failure
      }

    | IExport id ->
      let sta' =
        let ctx' =
          let var_val = {ctx.var_env[id] with exported=True} in
          let var_env' = ctx.var_env[id <- var_val] in
          {ctx with var_env = var_env'; result = True}
        in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with normal = Cn.singleton sta'})

    | ISequence ins1 ins2 ->
      let res1_normal, res1_other =
        Rs.separate_normal
          (interp_instr stk cnf inp ctx sta ins1)
      in
      let res2 = interp_instr' stk cnf inp res1_normal ins2 in
      Rs.union res2 res1_other

    | ISubshell ins ->
      let stas, stas_failure =
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta ins)
      in
      assert {
        forall sta' ctx' bhv.
        bhv <> BFailure ->
        eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', bhv) ->
        Cn.mem {state=sta'; context=ctx'; data=()} stas
      };
      let stas' =
        let aux sta =
          let ctx' = {ctx with result = sta.context.result} in
          {state=sta.state; context=ctx'; data=()}
        in
        Cn.map aux stas
      in
      let old_ctx_with_res sta = {sta with context=with_result sta.context.result ctx} in
      Rs.(union
           (inject inp stas')
           {empty with failure=Cn.map old_ctx_with_res stas_failure})
      ensures {
        forall sta' ctx'.
        eval_instruction stk (cnf, inp, ctx, sta) ins (sta', ctx', BFailure) ->
        Rs.mem {state=sta'; context=with_result ctx'.result ctx; data=()} BFailure result
      }

    | INoOutput ins ->
      Rs.map (reset_output sta)
        (interp_instr stk cnf inp ctx sta ins)

    | IIf ins1 ins2 ins3 ->
      let res1 = interp_instr stk cnf {inp with under_condition=True} ctx sta ins1 in
      let res1_normal, res1_other = Rs.separate_normal res1 in
      let res2 =
        let res1_true, res1_false =
          Cn.partition
            (fun sta -> sta.context.result)
            res1_normal
        in
        Rs.union
          (interp_instr' stk cnf inp res1_true ins2)
          (interp_instr' stk cnf inp res1_false ins3)
      in
      Rs.union res2 res1_other

    | ICallUtility id le ->
      let res, res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      let res' =
        let call_utility arg =
          let sta', args = arg in
          sym_interp_utility id ctx.cwd (filter_var_env ctx.var_env) args sta'
        in
        let for_call_result arg =
          let sta'', b = arg in
          let ctx' = with_result b ctx in
          {state=sta''; context=ctx'; data=()}
        in
        Rs.inject inp
          Cn.(map for_call_result
               (bind call_utility res))
      in
      let res_failures' =
        Rs.stas_as_failures ctx res_failures
      in
      Rs.union res' res_failures'

    | ICallFunction id le ->
      let arg_res, arg_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      let res =
        match ctx.func_env[id] with
        | Some ins -> (* Function defined as `ins` *)
            if stk = get_some cnf.stack_size then (* Stack overflow *)
              let aux arg =
                let sta', _ = arg in
                {state=sta'; context=ctx; data=()}
              in
              Rs.({empty with failure = Cn.map aux arg_res})
            else (* Execute function *)
              let res2 =
                let for_sym_state arg =
                  let sta1, args = arg in
                  let inp1 = {inp with argument0 = identifier_to_string id} in
                  let ctx1 = {ctx with arguments = args} in
                  interp_instr (stk+1) cnf inp1 ctx1 sta1 ins
                in
                Rs.bind_collection for_sym_state arg_res
              in
              Rs.({
                res2 with
                normal = Cn.union res2.normal res2.return_;
                return_ = Cn.empty;
              })
        | None -> (* Undefined function *)
            let set_res arg =
              let sta', _ = arg in
              let ctx' = with_result False ctx in
              {state = sta'; context = ctx'; data = ()}
            in
            Rs.inject inp (Cn.map set_res arg_res)
        end
      in
      let res_failures = Rs.stas_as_failures ctx arg_res_failures in
      Rs.union res res_failures

    | IShift bn ->
      match shift_arguments (option_get (mk_nat 1) bn).nat ctx.arguments with
      | Some args ->
        let ctx' = {ctx with result = True; arguments = args} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.({empty with normal = Cn.singleton sta'})
      | None ->
        let ctx' = {ctx with result = False} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.inject inp (Cn.singleton sta')
      end

    | IForeach id le ins ->
      let lst_res, lst_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      (* Run interpretation of foreach in one state *)
      let rec interp_foreach (b:bool) (ctx:context) (sta:state) (ss:list string) : Rs.t bool variant { ss } =
        match ss with
        | Nil ->
          Rs.({empty with normal=Cn.singleton {state=sta; context=ctx; data=b}})
        | Cons s ss' ->
          let res1_normal, res1_abort =
            let ctx' = {ctx with var_env = ctx.var_env[id <- s]'} in
            Rs.separate_normal
              (interp_instr stk cnf inp ctx' sta ins)
          in
          let for_normal sta1 = interp_foreach sta1.context.result sta1.context sta1.state ss' in
          let for_abort sta  = with_data sta.context.result sta in
          Rs.(union
                (bind_collection for_normal res1_normal)
                (map for_abort res1_abort))
        end
      in
      (* Execute foreach loop on a result from interp_list_expr *)
      let interp_foreach' arg =
        let sta', ss = arg in
        interp_foreach True ctx sta' ss
      in
      (* Move data to result *)
      let set_result sta'' =
        let ctx'' = with_result sta''.data sta''.context in
        with_data () {sta'' with context = ctx'' }
      in
      Rs.(union
           (map set_result
             (bind_collection interp_foreach' lst_res))
           (stas_as_failures ctx lst_res_failures))

    | IWhile ins1 ins2 ->
      let loop_limit = match cnf.loop_limit with Some n -> n | None -> absurd end in
      let rec interp_while ctr (stas: Cn.t (sym_state bool)) : Rs.t unit
        variant { get_some cnf.loop_limit - ctr }
        requires { ctr <= get_some cnf.loop_limit }
      = if ctr = loop_limit then
          Rs.(map (with_data ()) {empty with failure=stas})
        else
          let res1_normal, res1_abort =
            Rs.separate_normal
              (interp_instr' stk cnf {inp with under_condition=True} stas ins1)
          in
          let res1_true, res1_false =
            Cn.partition (fun sta -> sta.context.result) res1_normal
          in
          let res2_normal, res2_abort =
            Rs.separate_normal
              (interp_instr' stk cnf inp res1_true ins2)
          in
          let res3 = interp_while (ctr+1) res2_normal in
          let others =
            let res1_false' = Rs.({empty with normal=res1_false}) in
            Rs.(map (with_data ())
                 (union res2_abort
                  (union res1_abort res1_false')))
          in
          Rs.union res3 others
      in
      interp_while 0 (Cn.singleton ({state=sta; context=ctx; data=True}))

    | IPipe ins1 ins2 ->
      let stas1, stas1_failure =
        let sta' = {sta with stdout = Stdout.empty} in
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta' ins1)
      in
      let res2 =
        let stas1' =
          let set_stdin_stdout sta1 =
            let sta' = {sta1.state with stdout = sta.stdout; stdin = Stdout.to_stdin sta1.state.stdout} in
            {state=sta'; context=ctx; data=sta1.state.stdin}
          in
          Cn.map set_stdin_stdout stas1
        in
        interp_instr' stk cnf inp stas1' ins2
      in
      let revise sta2 =
        let sta2' = {sta2.state with stdin=sta2.data} in
        let ctx' = {ctx with result=sta2.context.result} in
        {state=sta2'; context=ctx'; data=()}
      in
      Rs.(union (map revise res2) {empty with failure = stas1_failure})

    | IExit code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta = {state=sta; context={ctx with result=r}; data=()} in
      Rs.({empty with exit = Cn.singleton sta})

    | IReturn code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with return_ = Cn.singleton sta})
    end

  with interp_instr' (stk:int) (cnf:config) (inp:input) (stas: Cn.t (sym_state 'a)) (ins:instruction) : Rs.t 'a
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins }
    ensures { (* Over-approximation *)
      forall sta sta' ctx' bhv.
      Cn.mem sta stas ->
      eval_instruction stk (cnf, inp, sta.context, sta.state) ins (sta', ctx', bhv) ->
      Rs.mem {state=sta'; context=ctx'; data=sta.data} bhv result
    }
  = let f sta =
      Rs.map (with_data sta.data) 
        (interp_instr stk cnf inp sta.context sta.state ins)
    in
    Rs.bind_collection f stas

  with interp_str_expr (stk:int) (b:bool) (cnf:config) (inp:input) (ctx:context) (sta:state) (se:string_expression)
    : Cn.t (state, option (string, bool))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_string_expr se }
    ensures { (* Over-approximation *)
      forall sta' res b.
      eval_str_expr stk b (cnf, inp, ctx, sta) se (sta', res) ->
      Cn.mem (sta', res) result
    }
  = match se with
    | SLiteral str ->
      Cn.singleton (sta, Some (str, b))
    | SVariable var ->
      let str = ctx.var_env[var]' in
      Cn.singleton (sta, Some (str, b))
    | SArgument n ->
      let str = nth_argument (Cons inp.argument0 ctx.arguments) n.nat in
      Cn.singleton (sta, Some (str, b))
    | SSubshell ins ->
      let res, stas_failures =
        let sta' = {sta with stdout=Stdout.empty} in
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta' ins)
      in
      let function for_res (sta1:sym_state unit) =
        let str = Stdout.to_string sta1.state.stdout in
        let sta1' = {sta1.state with stdout=sta.stdout} in
        let b' = sta1.context.result in
        sta1', Some  (str, b')
      in
      let res_non_failure = Cn.map for_res res in
      let res_failure = Cn.map (fun sta1 -> sta1.state, None) stas_failures in
      Cn.union res_non_failure res_failure
    | SConcat se1 se2 ->
      let res1: Cn.t (state, (string, bool)), res1_failures: Cn.t state =
        separate_options
          (interp_str_expr stk b cnf inp ctx sta se1)
      in
      let as_failure sta = sta, None in
      let for_res1 sta1 str1 b1 : Cn.t (state, option (string, bool)) =
        let res2, res2_failures =
          separate_options
            (interp_str_expr stk b1 cnf inp ctx sta1 se2)
        in
        let for_res2 arg2 =
          let sta2, (str2, b2) = arg2 in
          sta2, Some (str1^str2, b2)
        in
        Cn.(union
              (map for_res2 res2)
              (map as_failure res2_failures))
      in
      let res1' : Cn.t (state, option (string, bool)) =
        Cn.bind (fun arg1 -> let sta1, (str1, b1) = arg1 in for_res1 sta1 str1 b1) res1 in
      Cn.(union res1' (map as_failure res1_failures))
    end

  with interp_list_expr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (le:list_expression)
    : Cn.t (state, option (list string))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_list_expr le }
    ensures { (* Over-approximation *)
      forall sta' res le.
      eval_list_expr stk (cnf, inp, ctx, sta) le (sta', res) ->
      Cn.mem (sta', res) result
    }
  = match le with
    | Nil ->
      Cn.singleton (sta, Some Nil)
    | Cons (se, sp) le' ->
      let str_res1: Cn.t (state, (string, bool)), str_res1_failures: Cn.t state =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se : Cn.t (state, option (string, bool)))
      in
      let lst_res1: Cn.t (state, list string) = (* Non-failure string list results *)
        Cn.map (fun arg -> state_split_str sp arg) str_res1
      in
      let for_sta_strs arg =
        let sta1, strs1 = arg in
        let lst_res2: Cn.t (state, list string), lst_res2_failures: Cn.t state =
          separate_options
            (interp_list_expr stk cnf inp ctx sta1 le')
        in
        Cn.(union
             (map (fun arg -> state_concat strs1 arg) lst_res2)
             (map (fun sta -> sta, None) lst_res2_failures))
      in
      Cn.(union
           (bind for_sta_strs lst_res1)
           (map (fun sta -> sta, None) str_res1_failures))
    end

  let rec interp_function_definitions (fenv:func_env) (defs:list function_definition)
    variant { defs }
  = match defs with
    | Nil -> fenv
    | Cons (id, instr) defs' ->
      interp_function_definitions fenv[id <- Some instr]  defs'
    end

  let function only_states_with_result (res: bool) (stas: Cn.t (sym_state unit)) : Cn.t state =
    Cn.(map (fun sta -> sta.state)
          (filter (fun sta -> notb (xorb res sta.context.result))
          stas))

  let interp_program loop_limit stack_size inp stas pro : (Cn.t state, Cn.t state, Cn.t state)
    requires { 0 <= loop_limit }
    requires { 0 <= stack_size }
  = let stas, stas_failure =
      let cnf = { loop_limit = Some loop_limit; stack_size = Some stack_size } in
      let stas =
        let aux sta =
          let fenv = interp_function_definitions sta.context.func_env pro.function_definitions in
          {sta with context={sta.context with func_env = fenv}}
        in
        Cn.map aux stas
      in
      Rs.separate_non_failure
        (interp_instr' 0 cnf inp stas pro.instruction)
    in
    (only_states_with_result True stas,
     only_states_with_result False stas,
     Cn.map (fun sta -> sta.state) stas_failure)
end