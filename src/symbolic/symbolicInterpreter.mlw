module Constraints

  type variable
  (** abstract type for variables denoting nodes in the file system *)

  type feature
  (** abstract type for filenames (excluding "." and ".."), named
      "feature" in the tree constraint vocabulary *)

  type clause
  (** abstract type for tree constraints, [IMPORTANT] which are always satisfiable *)

  type path
end

(** A symbolic file system.

   The only symbolic part in this intepreter *)
module Filesystem

  use list.List
  use option.Option
  use Constraints

  (** A symbolic filesystem composed by a variable indicating root, constraints, and the
      current working directory `cwd` as feature path. root₀ may refer to the initial root
      variable. When provided it should not be pruned (“quantified over”) during symbolic
      execution of utilities. *)
  type filesystem = {
    root : variable;
    clause : clause;
    cwd : path;
    root0 : option variable;
  }
end

module State

  use Filesystem

  clone export semantics.AbstractState
    with type filesystem = filesystem

  use semantics.State as S
  function sem_state (sta:state) : S.state = {
    S.stdin = sta.stdin;
    S.stdout = sta.stdout;
    S.filesystem = ();
  }
end


module SymState

  use semantics.Context
  use State

  type sym_state 'a = {
    context: context;
    state: state;
    data: 'a (* Used to fiddle additional information through interp_instr': A stdin in pipe and the last reuslt in the loops *)
  }

  let function with_data data =
    fun sta ->
      {sta with data = data}
end

(** The symbolic interpretation of a program results describes multiple possible results
  *)
module Results

  use symbolicAuxiliaries.Fset
  use semantics.Input
  use semantics.Behaviour
  use semantics.Semantics
  use semantics.Context
  use State
  use SymState

  type t 'a = {
    normal: set (sym_state 'a);
    exit: set (sym_state 'a);
    return_: set (sym_state 'a);
    failure: set (sym_state 'a);
  }

  let constant empty = {
    normal = Fset.empty;
    exit = Fset.empty;
    return_ = Fset.empty;
    failure = Fset.empty;
  }

  (* let function results rs : set (sym_state 'a, behaviour) = *)
  (*   let with_bhv bhv sta = (sta, bhv) in *)
  (*   Fset. *)
  (*   (union (map (fun x -> with_bhv BNormal x) rs.normal) *)
  (*      (union (map (fun x -> with_bhv BExit x) rs.exit) *)
  (*         (union (map (fun x -> with_bhv BReturn x) rs.return_) *)
  (*            (map (fun x -> with_bhv BFailure x) rs.failure)))) *)


  predicate mem (sta:sym_state 'a) (bhv:behaviour) (rs:t 'a) =
    match bhv with
    | BNormal  -> Fset.mem sta rs.normal
    | BExit    -> Fset.mem sta rs.exit
    | BReturn  -> Fset.mem sta rs.return_
    | BFailure -> Fset.mem sta rs.failure
    end

  let function map (f:sym_state 'a -> sym_state 'b) (res:t 'a) : t 'b = {
    normal  = Fset.map f res.normal;
    exit    = Fset.map f res.exit;
    return_ = Fset.map f res.return_;
    failure = Fset.map f res.failure;
  }

  let function union (res1 res2: t 'a) : t 'a = {
    normal  = Fset.union res1.normal  res2.normal;
    exit    = Fset.union res1.exit    res2.exit;
    return_ = Fset.union res1.return_ res2.return_;
    failure = Fset.union res1.failure res2.failure;
  }

  lemma mem_union: forall sta bhv, rs1 rs2:t 'a.
    mem sta bhv (union rs1 rs2) <->
    (mem sta bhv rs1 \/ mem sta bhv rs2)

  lemma mem_map: forall sta': sym_state 'b, bhv, rs, f: sym_state 'a -> sym_state 'b.
    mem sta' bhv (map f rs) ->
    exists sta.
    mem sta bhv rs /\
    sta' = f sta

  let separate_normal (res:t 'a) : (normal: set (sym_state 'a), other: t 'a)
    ensures { normal = res.normal }
    ensures { other.normal = Fset.empty }
    ensures { other.exit = res.exit }
    ensures { other.return_ = res.return_ }
    ensures { other.failure = res.failure }
    ensures { forall s. Fset.mem s normal -> Fset.mem s res.normal }
    ensures { forall s bhv. mem s bhv other -> bhv <> BNormal /\ mem s bhv res }
  = res.normal, {res with normal = Fset.empty}

  let function separate_non_failure (res:t 'a) : (set (sym_state 'a), set (sym_state 'a))
    = union res.normal (union res.exit res.return_), res.failure

  let function all_states (res:t 'a) : set (sym_state 'a) =
    union res.normal (union res.exit (union res.return_ res.failure))

  let function failures (ctx:context) (stas:set state) : t unit
    ensures { result.normal = Fset.empty }
    ensures { result.exit = Fset.empty }
    ensures { result.return_ = Fset.empty }
    ensures { forall s. Fset.mem s result.failure -> Fset.mem s.state stas /\ s.context=ctx /\ s.data = () }
  = let aux sta = {state=sta; context=ctx; data=()} in
    { empty with failure = Fset.map aux stas }

  let function is_state_behaviour (inp:input) (bhv:behaviour) : sym_state 'a -> bool = fun sta ->
    eq_behaviour bhv
      (behaviour inp sta.context.result)

  let function inject (inp:input) (stas:set (sym_state 'a)) : t 'a
    ensures { stas = Fset.union result.normal result.exit }
    ensures { forall s. Fset.mem s result.normal -> Fset.mem s stas /\ behaviour inp s.context.result = BNormal }
    ensures { forall s. Fset.mem s result.exit -> Fset.mem s stas /\ behaviour inp s.context.result = BExit }
    ensures { result.return_ = Fset.empty }
    ensures { result.failure = Fset.empty }
  = {normal = Fset.filter (is_state_behaviour inp BNormal) stas;
     exit = Fset.filter (is_state_behaviour inp BExit) stas;
     return_ = Fset.empty;
     failure = Fset.empty}
end

module Interpreter

  use bool.Bool
  use option.Option
  use int.Int
  use list.List, list.Mem, list.Map
  use list.Append
  use mystring.String
  use syntax.Syntax
  use auxiliaries.Auxiliaries
  use semantics.Behaviour
  use semantics.Input
  use semantics.Config
  use semantics.Buffers
  use semantics.Arguments
  use semantics.State as SemState
  use semantics.Semantics as Sem
  use semantics.Context
  use symbolicAuxiliaries.Auxiliaries
  use symbolicAuxiliaries.Fset
  use State
  use SymState
  use Results as Rs

  (* Implemented in OCaml *)
  val function interp_utility identifier var_env (list string) state : set (state, bool)

  lemma list_mem_set_mem: forall x:'a, s. mem x s <-> Mem.mem x (Fset.to_list s)

  let separate_options (sta_opts: set (state, option 'a)) : (results: set (state, 'a), failures: set state)
    ensures {
      forall sta x.
      mem (sta, x) results <->
      mem (sta, Some x) sta_opts
    }
    ensures {
      forall sta.
      mem sta failures <->
      mem (sta, None) sta_opts
    }
  = let rec separate_options' (sta_opts: list (state, option 'a))
      : (results: list (state, 'a), failures: list state)
      variant { sta_opts }
      ensures {
        forall sta x.
        Mem.mem (sta, x) results <->
        Mem.mem (sta, Some x) sta_opts
      }
      ensures {
        forall sta.
        Mem.mem sta failures <->
        Mem.mem (sta, None) sta_opts
      }
    = match sta_opts with
      | Nil -> Nil, Nil
      | Cons (sta, x_opt) sta_opts' ->
        let results, failures = separate_options' sta_opts' in
        match x_opt with
        | Some x ->
          Cons (sta, x) results, failures
        | None ->
          results, Cons sta failures
        end
      end
    in
    let results, failures = separate_options' (Fset.to_list sta_opts) in
    Fset.of_list results, Fset.of_list failures

  lemma set_mem_map: forall y: 'b, s: set 'a, f: 'a -> 'b.
    mem y (map f s) <-> (exists x. mem x s /\ f x = y)

  let function get_some (o: option 'a) : 'a
    requires { o <> None }
  = match o with
    | Some x -> x
    | None -> absurd
    end

  let rec function size_instr (ins:instruction) : int
    variant { ins }
    ensures { 0 < result }
  = 1 + match ins with
    | IReturn _
    | IExit _
    | IShift _ -> 0
    | INot ins1
    | INoOutput ins1
    | ISubshell ins1 -> size_instr ins1
    | IAssignment _ se  -> size_string_expr se
    | ICallUtility _ le
    | ICallFunction _ le -> size_list_expr le
    | ISequence ins1 ins2
    | IPipe ins1 ins2
    | IWhile ins1 ins2 -> size_instr ins1 + size_instr ins2
    | IForeach _ le ins -> size_list_expr le + size_instr ins
    | IIf ins1 ins2 ins3 -> size_instr ins1 + size_instr ins2 + size_instr ins3
    end
  with function size_list_expr (le:list_expression): int
    variant { le }
    ensures { 0 < result }
  = 1 + match le with
    | Nil -> 0
    | Cons se_sp le' ->
      size_pair se_sp + size_list_expr le'
    end
  with function size_pair (se_sp: (string_expression, split)) : int
    variant { se_sp }
    ensures { 0 < result }
  = let se, _ = se_sp in
    size_string_expr se
  with function size_string_expr (se:string_expression): int
    variant { se }
    ensures { 0 < result }
  = 1 + match se with
    | SLiteral _
    | SVariable _
    | SArgument _ -> 0
    | SSubshell ins -> size_instr ins
    | SConcat se1 se2 -> size_string_expr se1 + size_string_expr se2
    end

  let rec lemma size_string_expr_list_expr (le:list_expression)
    ensures { forall se sp. size_string_expr se < size_list_expr (Cons (se, sp) le) }
  = match le with
    | Nil -> ()
    | Cons _ le' -> size_string_expr_list_expr le'
    end

  let function flip_result sta' =
    let res' = notb sta'.context.result in
    let ctx' = {sta'.context with result = res'} in
    {sta' with context = ctx'}

  let function reset_output sta sta' =
    let sta'' = {sta'.state with stdout = sta.stdout} in
    {sta' with
      state = sta''}

  let function state_split_str sp arg =
    let sta, (str, _:bool) = arg in
    sta, Sem.split sp str

  let function state_concat strs1 arg =
    let sta2, strs2 = arg in
    sta2, Some (strs1++strs2)

  let rec interp_instr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (ins:instruction)
    : Rs.t unit
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins, -1 }
    ensures {
      forall bhv sta'.
      Rs.mem sta' bhv result ->
      Sem.eval_instruction stk (cnf, inp, ctx, sem_state sta) ins
        (sem_state sta'.state, sta'.context, bhv)
    }
  = match ins with

    | INot ins1 ->
      let res = interp_instr stk cnf {inp with under_condition=True } ctx sta ins1 in
      Rs.({
        normal = Fset.map flip_result res.normal;
        return_ = Fset.map flip_result res.return_;
        exit = res.exit;
        failure = res.failure;
      })

    | IAssignment var se ->
      let str_stas, str_stas_failure =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se)
      in
      let res =
        let for_str_sta arg =
          let sta', (str, result) = arg in
          let ctx' = {
            ctx with
            var_env = Env.(ctx.var_env[var <- str]);
            result = result;
          }
          in
          {state = sta'; context = ctx'; data = ()}
        in
        Rs.inject inp
          (Fset.map for_str_sta str_stas)
      in
      let res_failure = Rs.failures ctx str_stas_failure in
      Rs.union res res_failure

    | ISequence ins1 ins2 ->
      let res1_normal, res1_other =
        Rs.separate_normal
          (interp_instr stk cnf inp ctx sta ins1)
      in
      let res2 = interp_instr' stk cnf inp res1_normal ins2 in
      Rs.union res2 res1_other

    | ISubshell ins ->
      let stas, stas_failure =
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta ins)
      in
      let stas' =
        let aux sta =
          let ctx' = {ctx with result = sta.context.result} in
          {state=sta.state; context=ctx'; data=()}
        in
        map aux stas
      in
      Rs.(union (inject inp stas')
            {empty with failure = stas_failure})

    | INoOutput ins ->
      Rs.map (reset_output sta)
        (interp_instr stk cnf inp ctx sta ins)

    | IIf ins1 ins2 ins3 ->
      let res1 = interp_instr stk cnf {inp with under_condition=True} ctx sta ins1 in
      let res1_normal, res1_other = Rs.separate_normal res1 in
      let res2 =
        let res1_true, res1_false =
          Fset.partition
            (fun sta -> sta.context.result)
            res1_normal
        in
        Rs.union
          (interp_instr' stk cnf inp res1_true ins2)
          (interp_instr' stk cnf inp res1_false ins3)
      in
      Rs.union res2 res1_other

    | ICallUtility id le ->
      let res, res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      let res' =
        let call_utility arg =
          let sta', args = arg in
          interp_utility id ctx.var_env args sta' (*FIXME: export?*)
        in
        let for_call_result arg =
          let sta'', b = arg in
          let ctx' = with_result b ctx in
          {state=sta''; context=ctx'; data=()}
        in
        Rs.inject inp
          (map for_call_result
             (bind call_utility res))
      in
      let res_failures' =
        Rs.failures ctx res_failures
      in
      Rs.union res' res_failures'

    | ICallFunction id le ->
      let arg_res, arg_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      let res =
        match Env.(ctx.func_env[id]) with
        | Some ins ->
            if stk = get_some cnf.stack_size then
              let aux arg =
                let sta', _ = arg in
                {state=sta'; context=ctx; data=()}
              in
              Rs.({empty with failure = Fset.map aux arg_res})
            else
              let res2 =
                let rec for_arg_res (res:list (state, list string)) : Rs.t unit variant { res } =
                  match res with
                  | Nil -> Rs.empty
                  | Cons (sta1, args) res' ->
                    let inp1 = {inp with argument0 = identifier_to_string id} in
                    let ctx1 = {ctx with arguments = args} in
                    Rs.union
                      (interp_instr (stk+1) cnf inp1 ctx1 sta1 ins)
                      (for_arg_res res')
                  end
                in
                for_arg_res (Fset.to_list arg_res)
              in
              Rs.({
                res2 with
                normal = union res2.normal res2.return_;
                return_ = Fset.empty;
              })
        | None ->
            let sym_state arg =
              let sta', _ = arg in
              let ctx' = with_result False ctx in
              {state = sta'; context = ctx'; data = ()}
            in
            Rs.inject inp (Fset.map sym_state arg_res)
        end
      in
      let res_failures = Rs.failures ctx arg_res_failures in
      Rs.union res res_failures

    | IShift bn ->
      match shift_arguments (option_get (mk_nat 1) bn).nat ctx.arguments with
      | Some args ->
        let ctx' = {ctx with result = True; arguments = args} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.({empty with normal = Fset.singleton sta'})
      | None ->
        let ctx' = {ctx with result = False} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.inject inp (Fset.singleton sta')
      end

    | IForeach id le ins ->
      let lst_res, lst_res_failures =
        separate_options
          (interp_list_expr stk cnf inp ctx sta le)
      in
      (* Run interpretation of foreach in one state *)
      let rec interp_foreach (b:bool) (ctx:context) (sta:state) (ss:list string) : Rs.t bool variant { ss } =
        match ss with
        | Nil ->
          let normal = singleton {state = sta; context = ctx; data = b} in
          Rs.({empty with normal = normal})
        | Cons s ss' ->
          let res1_normal, res1_abort =
            let ctx' = {ctx with var_env = Env.(ctx.var_env[id <- s])} in
            Rs.separate_normal
              (interp_instr stk cnf inp ctx' sta ins)
          in
          let rec for_normal (res1_normal:list (sym_state unit)) : Rs.t bool variant { res1_normal } =
            (* TODO Reuse loop_res instead? *)
            match res1_normal with
            | Nil -> Rs.empty
            | Cons sta1 res1_normal' ->
              Rs.union
                (interp_foreach sta1.context.result sta1.context sta1.state ss')
                (for_normal res1_normal')
            end
          in
          let for_abort (sta:sym_state unit) : sym_state bool =
            with_data sta.context.result sta
          in
          Rs.union
            (for_normal (Fset.to_list res1_normal))
            (Rs.map for_abort res1_abort)
        end
      in
      (* Run interpretation of foreach loop for every state resulting from interp_list_expr *)
      let rec loop_res (lst_res: list (state, list string)) : Rs.t bool variant { lst_res } =
        match lst_res with
        | Nil -> Rs.empty
        | Cons (sta', ss) lst_res' ->
          Rs.union
            (interp_foreach True ctx sta' ss)
            (loop_res lst_res')
        end
      in
      (* Move data to result *)
      let set_result sta'' =
        let ctx'' = with_result sta''.data sta''.context in
        with_data () {sta'' with context = ctx'' }
      in
      Rs.(union
           (map set_result
             (loop_res (Fset.to_list lst_res)))
           (Rs.failures ctx lst_res_failures))

    | IWhile ins1 ins2 ->
      let loop_limit = match cnf.loop_limit with Some n -> n | None -> absurd end in
      let rec interp_while ctr (stas: set (sym_state bool)) : Rs.t unit
        variant { get_some cnf.loop_limit - ctr }
        requires { ctr <= get_some cnf.loop_limit }
      = if ctr = loop_limit then
          Rs.(map (with_data ())
                {empty with failure = stas})
        else
          let res1_normal, res1_abort =
            Rs.separate_normal
              (interp_instr' stk cnf {inp with under_condition=True} stas ins1)
          in
          let res1_true, res1_false =
            Fset.partition (fun sta -> sta.context.result) res1_normal
          in
          let res2_normal, res2_abort =
            Rs.separate_normal
              (interp_instr' stk cnf inp res1_true ins2)
          in
          let res3 = interp_while (ctr+1) res2_normal in
          let others =
            let res1_false' = Rs.({empty with normal=res1_false}) in
            Rs.(map (with_data ())
                 (union res2_abort
                  (union res1_abort res1_false')))
          in
          Rs.union res3 others
      in
      interp_while 0 (Fset.singleton ({state=sta; context=ctx; data=True}))

    | IPipe ins1 ins2 ->
      let stas1, stas1_failure =
        let sta' = {sta with stdout = Stdout.empty} in
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta' ins1)
      in
      let res2 =
        let stas1' =
          let set_stdin_stdout sta1 =
            let sta' = {
              sta1.state with
              stdout = sta.stdout;
              stdin = Stdout.to_stdin sta1.state.stdout
            } in
            {state=sta'; context=ctx; data=sta1.state.stdin}
          in
          Fset.map set_stdin_stdout stas1
        in
        interp_instr' stk cnf inp stas1' ins2
      in
      let revise sta2 =
        let sta2' = {sta2.state with stdin = sta2.data} in
        let ctx' = {ctx with result = sta2.context.result} in
        {state = sta2'; context = ctx'; data=()}
      in
      Rs.(union
            (map revise res2)
            {empty with failure = stas1_failure})

    | IExit code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with exit = Fset.singleton sta})

    | IReturn code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {state = sta; context = ctx'; data=()}
      in
      Rs.({empty with return_ = Fset.singleton sta})
    end

  with interp_instr' (stk:int) (cnf:config) (inp:input) (stas: set (sym_state 'a)) (ins:instruction) : Rs.t 'a
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_instr ins, cardinal stas }
    ensures {
      forall bhv sta'.
      Rs.mem sta' bhv result ->
      exists sta.
      mem sta stas /\
      Sem.eval_instruction stk (cnf, inp, sta.context, sem_state sta.state) ins
        (sem_state sta'.state, sta'.context, bhv)
    }
  = let rec aux (stas: list (sym_state 'a)) : Rs.t 'a
      variant { stas }
      ensures { forall sta' bhv.
        Rs.mem sta' bhv result ->
        exists sta.
        Mem.mem sta stas /\
        sta'.data = sta.data /\
        Sem.eval_instruction stk (cnf, inp, sta.context, sem_state sta.state) ins
          (sem_state sta'.state, sta'.context, bhv)
      }
    = match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' ->
        let res = 
          Rs.map (with_data sta.data) 
            (interp_instr stk cnf inp sta.context sta.state ins)
        in
        assert {
          forall sta' bhv.
          Rs.mem sta' bhv res ->
          sta'.data = sta.data /\
          Sem.eval_instruction stk (cnf, inp, sta.context, sem_state sta.state) ins
            (sem_state sta'.state, sta'.context, bhv)
        };
        Rs.union res (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_str_expr (stk:int) (b:bool) (cnf:config) (inp:input) (ctx:context) (sta:state) (se:string_expression)
    : set (state, option (string, bool))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_string_expr se, -1 }
    ensures {
      forall sta' res.
      mem (sta', res) result ->
      Sem.eval_str_expr stk b (cnf, inp, ctx, sem_state sta) se
        (sem_state sta', res)
    }
  = match se with
    | SLiteral str ->
      singleton (sta, Some (str, b))
    | SVariable var ->
      let str = Env.(ctx.var_env[var]) in
      singleton (sta, Some (str, b))
    | SArgument n ->
      let str = nth_argument (Cons inp.argument0 ctx.arguments) n.nat in
      singleton (sta, Some (str, b))
    | SSubshell ins ->
      let res, stas_failures =
        let sta' = {sta with stdout=Stdout.empty} in
        Rs.separate_non_failure
          (interp_instr stk cnf inp ctx sta' ins)
      in
      let for_non_failure (sta1:sym_state unit)
        : (sta: state, res: option (string, bool))
        ensures { res <> None }
      = let str = Stdout.to_string sta1.state.stdout in
        let sta1' = {sta1.state with stdout=sta.stdout} in
        let b' = sta1.context.result in
        sta1', Some  (str, b')
      in
      let res_non_failure = map for_non_failure res in
      (* assert { *)
      (*   forall sta', str_b. *)
      (*   mem (sta', str_b) res_non_failure -> *)
      (*   exists str b' sta'. *)
      (*   str_b = Some (str, b') /\ *)
      (*   exists sta bhv. *)
      (*   mem sta res /\ *)
      (*   bhv <> BFailure /\ *)
      (*   exists ctx'. *)
      (*   let sta1 = sem_state sta.state in *)
      (*   Sem.eval_instruction stk (cnf, inp, ctx, {sta1 with SemState.stdout=Stdout.empty}) ins (sem_state sta', ctx', bhv) *)
      (* }; *)
      let res_failure = map (fun sta1 -> sta1.state, None) stas_failures in
      (* assert { *)
      (*   forall sta' n. *)
      (*   mem (sta, n) res_failure -> *)
      (*   (n = None /\ *)
      (*    exists ctx'. *)
      (*    let sta1 = sem_state sta in *)
      (*    Sem.eval_instruction stk (cnf, inp, ctx, {sta1 with SemState.stdout=Stdout.empty}) ins (sta', ctx', BFailure)) *)
      (* }; *)
      let res = union res_non_failure res_failure in
      (* assert { forall x. mem x res -> (mem x res_non_failure \/ mem x res_failure) }; *)
      res
    | SConcat se1 se2 ->
      let res1 = interp_str_expr stk b cnf inp ctx sta se1 in
      let rec for_res1 (res1: list (state, option (string, bool))) : set (state, option (string, bool))
        variant { res1 }
        (* ensures { *)
        (*   forall sta' r'. *)
        (*   mem (sta', r') result -> *)
        (*   exists sta b. *)
        (*   Mem.mem (sta, r) res1 /\ *)

        (* } *)
      = match res1 with
        | Nil ->
          empty
        | Cons (sta1, None) res1' ->
          Fset.add (sta1, None)
            (for_res1 res1')
        | Cons (sta1, Some (str1, b1)) res1' ->
          let stas = interp_str_expr stk b1 cnf inp ctx sta1 se2 in
          let concat arg =
            match arg with
            | sta2, None ->
              sta2, None
            | sta2, Some (str2, b2) ->
              sta2, Some (str1^str2, b2)
            end
          in
          Fset.union
            (Fset.map concat stas)
            (for_res1 res1')
        end
      in
      for_res1 (Fset.to_list res1)
    end

  with interp_list_expr (stk:int) (cnf:config) (inp:input) (ctx:context) (sta:state) (le:list_expression)
    : set (state, option (list string))
    requires { cnf.loop_limit <> None /\ cnf.stack_size <> None }
    requires { stk <= get_some cnf.stack_size }
    variant { get_some cnf.stack_size - stk, get_some cnf.loop_limit + 1, size_list_expr le, -1 }
    ensures {
      forall sta' res.
      mem (sta', res) result ->
      Sem.eval_list_expr stk (cnf, inp, ctx, sem_state sta) le
        (sem_state sta', res)
    }
  = match le with
    | Nil ->
      singleton (sta, Some Nil)
    | Cons (se, sp) le' ->
      let str_res1: set (state, (string, bool)), str_res1_failures: set state =
        separate_options
          (interp_str_expr stk True cnf inp ctx sta se)
      in
      assert {
        forall sta1 str b.
        mem (sta1, (str, b)) str_res1 ->
        Sem.eval_str_expr stk True (cnf, inp, ctx, sem_state sta) se
          (sem_state sta1, Some (str, b))
      };
      let lst_res1: set (state, list string) = (* Non-failure string list results *)
        map (fun arg -> state_split_str sp arg) str_res1
      in
      assert {
        forall sta1 li.
        mem (sta1, li) lst_res1 ->
        exists str b.
        mem (sta1, (str, b)) str_res1 /\
        Sem.eval_str_expr stk True (cnf, inp, ctx, sem_state sta) se
          (sem_state sta1, Some (str, b)) /\
        li = Sem.split sp str
      };
      let rec for_lst_res1 (lst_res1_lst: list (state, list string)) : set (state, option (list string))
        variant { lst_res1_lst }
        ensures {
          forall sta2 strs2.
          mem (sta2, Some strs2) result ->
          exists sta1 strs1 strs2'.
          Mem.mem (sta1, strs1) lst_res1_lst /\
          Sem.eval_list_expr stk (cnf, inp, ctx, sem_state sta1) le'
            (sem_state sta2, Some strs2') /\
          strs2 = strs1++strs2'
        }
        ensures {
          forall sta2.
          mem (sta2, None) result ->
          exists sta1 strs1.
          Mem.mem (sta1, strs1) lst_res1_lst /\
          Sem.eval_list_expr stk (cnf, inp, ctx, sem_state sta1) le'
            (sem_state sta2, None)
        }
      = match lst_res1_lst with
        | Nil -> empty
        | Cons (sta1, strs1) lst_res1_lst' ->
          let lst_res2: set (state, list string), lst_res2_failures: set state =
            separate_options
              (interp_list_expr stk cnf inp ctx sta1 le')
          in
          let lst_res12 : set (state, option (list string)) =
            Fset.map (fun arg -> state_concat strs1 arg) lst_res2
          in
          assert {
            forall sta2 res2.
            mem (sta2, res2) lst_res12 ->
            exists strs2'.
            Sem.eval_list_expr stk (cnf, inp, ctx, sem_state sta1) le'
              (sem_state sta2, Some strs2') /\
            res2 = Some (strs1++strs2')
          };
          let lst_res2_failures' : set (state, option (list string)) =
            map (fun sta -> sta, None) lst_res2_failures
          in
          assert {
            forall sta2 res2.
            mem (sta2, res2) lst_res2_failures' ->
            res2 = None /\
            Sem.eval_list_expr stk (cnf, inp, ctx, sem_state sta1) le'
              (sem_state sta2, None)
          };
          let lst_res1'' : set (state, option (list string)) =
            for_lst_res1 lst_res1_lst'
          in
          union (union lst_res12 lst_res1'') lst_res2_failures'
        end
      in
      let lst_res1' : set (state, option (list string)) =
        for_lst_res1 (Fset.to_list lst_res1)
      in
      let str_res1_failures' : set (state, option (list string)) =
        map (fun sta -> sta, None) str_res1_failures
      in
      union lst_res1' str_res1_failures'
    end

  let rec interp_function_definitions (fenv:func_env) (defs:list function_definition)
    variant { defs }
  = match defs with
    | Nil -> fenv
    | Cons (id, instr) defs' ->
      interp_function_definitions Env.(fenv[id <- Some instr])  defs'
    end

  let function only_states_with_result (res: bool) (stas: set (sym_state unit)) : set state =
    map (fun sta -> sta.state)
      (filter (fun sta -> notb (xorb res sta.context.result))
        stas)

  let interp_program loop_limit stack_size inp ctx sta pro : (set state, set state, set state)
    requires { 0 <= loop_limit }
    requires { 0 <= stack_size }
  = let stas, stas_failure =
      let fenv = interp_function_definitions ctx.func_env pro.function_definitions in
      let ctx' = {ctx with func_env = fenv} in
      let cnf = { loop_limit = Some loop_limit; stack_size = Some stack_size } in
      Rs.separate_non_failure
        (interp_instr 0 cnf inp ctx' sta pro.instruction)
    in
    (only_states_with_result True stas,
     only_states_with_result False stas,
     Fset.map (fun sta -> sta.state) stas_failure)
end