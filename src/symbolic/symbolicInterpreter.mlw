(* NOTE: Why3 exports a higher-order call `f g` to f (g ())` -- as a workaround, such
   calls are written as `f (fun xyz -> g xyz)` below. *)

module Constraints

  type variable
  (** abstract type for variables denoting nodes in the file system *)

  type feature
  (** abstract type for filenames (excluding "." and ".."), named
      "feature" in the tree constraint vocabulary *)

  type clause
  (** abstract type for tree constraints, [IMPORTANT] which are always satisfiable *)

  type path
end

(** A symbolic file system.

   The only symbolic part in this intepreter *)
module Filesystem

  use list.List
  use option.Option
  use Constraints

  (** A symbolic filesystem composed by a variable indicating root, constraints, and the
      current working directory `cwd` as feature path. root₀ may refer to the initial root
      variable. When provided it should not be pruned (“quantified over”) during symbolic
      execution of utilities. *)
  type filesystem = {
    root : variable;
    clause : clause;
    cwd : path;
    root0 : option variable;
  }
end

module State
  use Filesystem
  clone export semantics.AbstractState
    with type filesystem = filesystem 
end

module Env
  use syntax.Syntax
  type t 'value
  val constant empty: t 'value
  val function get (env:t 'value) (id:identifier) (default:'value) : 'value
  val function set (env:t 'value) (id:identifier) (value:'value) : t 'value
  val function functional (env:t 'value) (default:'value) : identifier -> 'value
end

module Context
  use option.Option
  use list.List
  use mystring.String
  use syntax.Syntax
  use Env

  type var_env = Env.t string
  type func_env = Env.t (option instruction)

  type context = {
    var_env: var_env;
    func_env: func_env;
    arguments: list string;
    result: bool; (* previous result ($?) for input state, current result for output state *)
  }

  let constant empty_context = {
    var_env = Env.empty; 
    func_env = Env.empty;
    arguments = Nil;
    result = True;
  }

  use semantics.Context as C

  let function contextx (c:context) : C.context = {
    C.var_env = Env.functional c.var_env String.empty;
    C.func_env = Env.functional c.func_env None;
    C.arguments = c.arguments;
    C.result = c.result;
  }

  let function with_result ret ctx =
    ensures { result.result = ret }
    ensures { result.var_env = ctx.var_env }
    ensures { result.func_env = ctx.func_env }
    ensures { result.arguments = ctx.arguments }
    { ctx with result = ret }
end

module SymState

  use Context
  use State

  type sym_state 'a = {
    context: context;
    state: state;
    data: 'a (* Used to fiddle additional information through interp_instr': A stdin in pipe and the last reuslt in the loops *)
  }

  let function with_data data =
    fun sta ->
      {sta with data = data}
end

(** The symbolic interpretation of a program results describes multiple possible results
  *)
module Results

  use symbolicAuxiliaries.Fset
  use semantics.Input
  use semantics.Behaviour
  use semantics.Semantics
  use Context
  use State
  use SymState

  type t 'a = {
    normal: set (sym_state 'a);
    exit: set (sym_state 'a);
    return_: set (sym_state 'a);
  }

  let constant empty = {
    normal = Fset.empty;
    exit = Fset.empty;
    return_ = Fset.empty;
  }

  let separate_normal res =
    res.normal, {res with normal = Fset.empty}

  let map f res = {
    normal = Fset.map f res.normal;
    exit = Fset.map f res.exit;
    return_ = Fset.map f res.return_;
  }

  let union res1 res2 = Fset.({
    normal  = union res1.normal  res2.normal;
    exit    = union res1.exit    res2.exit;
    return_ = union res1.return_ res2.return_;
  })

  let function all res =
    union res.normal (union res.exit res.return_)

  let inject (inp:input) (stas:set (sym_state 'a)) : t 'a
    ensures { all result = stas }
    ensures { forall s. mem s result.normal -> behaviour' inp (contextx s.context) = BNormal }
    ensures { forall s. mem s result.exit -> behaviour' inp (contextx s.context) = BExit }
  = let aux bhv = fun sta ->
      match bhv, behaviour' inp (contextx sta.context) with
      | BNormal, BNormal -> True
      | BExit, BExit -> True
      | _ -> False
      end
    in
    {normal = Fset.filter (aux BNormal) stas;
     exit = Fset.filter (aux BExit) stas;
     return_ = Fset.empty}
end

module Interpreter

  use bool.Bool
  use option.Option
  use int.Int
  use list.List
  use list.Append
  use mystring.String
  use syntax.Syntax
  use semantics.Env
  use semantics.Behaviour
  use semantics.Input
  use semantics.Buffers
  use semantics.Arguments
  use semantics.Semantics as Sem
  use auxiliaries.Auxiliaries
  use symbolicAuxiliaries.Auxiliaries
  use symbolicAuxiliaries.Fset
  use State
  use Context
  use SymState
  use Results as Rs

  (* Implemented in OCaml *)
  val function interp_utility identifier (list string) state : set (state, bool)

  let rec interp_instr (inp:input) (ctx:context) (sta:state) (ins:instruction)
    : Rs.t unit
    diverges
  = match ins with

    | IAssignment var se ->
      let res = interp_str_expr True inp ctx sta se in
      let aux arg =
        let sta', result, str = arg in
        let ctx' = {
          ctx with
          var_env = Env.set ctx.var_env var str;
          result = result;
        }
        in
        {state = sta'; context = ctx'; data = ()}
      in
      Rs.inject inp (Fset.map (fun xyz -> aux xyz) res)

    | ISequence ins1 ins2 ->
      let res1_normal, res1_other =
        Rs.separate_normal 
          (interp_instr inp ctx sta ins1)
      in
      let res2 = interp_instr_unit' inp res1_normal ins2 in
      Rs.union res2 res1_other

    | ISubshell ins ->
      let res = interp_instr inp ctx sta ins in
      let stas = Rs.all res in
      Rs.inject inp stas

    | INot ins ->
      let res = interp_instr inp ctx sta ins in
      let flip_result sta =
        let res' = notb sta.context.result in
        let ctx = {sta.context with result = res'} in
        {sta with context = ctx}
      in
      Rs.({
        normal = Fset.map (fun xyz -> flip_result xyz) res.normal;
        return_ = Fset.map (fun xyz -> flip_result xyz) res.return_;
        exit = res.exit})

    | INoOutput ins -> 
      let res = interp_instr inp ctx sta ins in
      let reset_output sta =
        let sta' = {sta.state with stdout = sta.state.stdout} in
        {sta with state = sta'}
      in
      Rs.({normal = Fset.map (fun xyz -> reset_output xyz) res.normal;
           exit = Fset.map (fun xyz -> reset_output xyz) res.exit;
           return_ = Fset.map (fun xyz -> reset_output xyz) res.return_})

    | IIf ins1 ins2 ins3 ->
      let res1 = interp_instr {inp with under_condition=True} ctx sta ins1 in
      let res1_normal, res1_other = Rs.separate_normal res1 in
      let res2 =
        let res1_true, res1_false =
          Fset.partition
            (fun sta -> sta.context.result)
            res1_normal
        in
        Rs.union
          (interp_instr_unit' inp res1_true ins2)
          (interp_instr_unit' inp res1_false ins3)
      in
      Rs.union res2 res1_other

    | ICallUtility id le ->
      let res = interp_list_expr inp ctx sta le in
      let stas' : set (state, bool) = 
        let aux arg : set (state, bool) =
          let sta', args = arg in
          interp_utility id args sta'
        in
        Fset.bind (fun xyz -> aux xyz) res
      in
      let sym_stas =
        let mk_sym_sta arg =
          let sta'', b = arg in
          let ctx' = with_result b ctx in
          {state = sta''; context = ctx'; data = ()}
        in
        Fset.map (fun xyz -> mk_sym_sta xyz) stas'
      in
      Rs.inject inp sym_stas

    | ICallFunction id le ->
      let res = interp_list_expr inp ctx sta le in
      match Env.get ctx.func_env id None with
      | Some ins ->
        let rec loop_res (res:list (state, list string)) : Rs.t unit =
          match res with
          | Nil -> Rs.empty
          | Cons (sta1, args) res' ->
            let inp1 = {inp with argument0 = identifier_to_string id} in
            let ctx1 = {ctx with arguments = args} in
            Rs.union
              (interp_instr inp1 ctx1 sta1 ins)
              (loop_res res')
          end
        in
        let res2 = loop_res (Fset.to_list res) in
        Rs.({normal = union res2.normal res2.return_;
             exit = res2.exit;
             return_ = Fset.empty})
      | None ->
        let mk_sym_state (arg:(state,list string)) =
          let sta', _ = arg in
          let ctx' = with_result False ctx in
          {state = sta'; context = ctx'; data = ()}
        in
        Rs.inject inp (Fset.map (fun xyz -> mk_sym_state xyz) res)
      end

    | IShift bn ->
      match shift_arguments (option_get (mk_nat 1) bn).nat ctx.arguments with
      | Some args ->
        let ctx' = {ctx with result = True; arguments = args} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.({empty with normal = Fset.singleton sta'})
      | None ->
        let ctx' = {ctx with result = False} in
        let sta' = {state = sta; context = ctx'; data=()} in
        Rs.inject inp (Fset.singleton sta')
      end

    | IForeach id le ins ->
      let res : set (state, list string) = interp_list_expr inp ctx sta le in
      let rec interp_foreach b ctx sta ss : Rs.t bool =
        match ss with
        | Nil ->
          let sym_sta = {state = sta; context = ctx; data = b} in
          Rs.({empty with normal = singleton sym_sta})
        | Cons s ss' ->
          let rec steps res1_normal =
            match res1_normal with
            | Nil -> Rs.empty
            | Cons sta1 res1_normal' ->
              Rs.union
                (interp_foreach sta1.context.result sta1.context sta1.state ss')
                (steps res1_normal')
            end
          in
          let abort sta = with_data sta.context.result sta in
          let ctx' = {ctx with var_env = Env.set ctx.var_env id s} in
          let res1_normal, res1_other = Rs.separate_normal (interp_instr inp ctx' sta ins) in
          Rs.union
            (steps (Fset.to_list res1_normal))
            (Rs.map (fun xyz -> abort xyz) res1_other)
        end
      in
      let rec loop_res (res: list (state, list string)) : Rs.t bool =
        match res with
        | Nil -> Rs.empty
        | Cons (sta', ss) res' ->
          Rs.union
            (interp_foreach True ctx sta' ss)
            (loop_res res')
        end
      in
      let set_result sta'' =
        let ctx'' = with_result sta''.data sta''.context in
        with_data () {sta'' with context = ctx'' }
      in
      Rs.map (fun xyz -> set_result xyz)
        (loop_res (Fset.to_list res))

    | IWhile ins1 ins2 ->
      let rec interp_while ctr (stas: set (sym_state bool)) : Rs.t unit =
        if ctr = 0 then
          Rs.(map (with_data ()) {empty with exit = stas})
        else
          let res1_normal, res1_other =
            Rs.separate_normal
              (interp_instr_bool' cnf {inp with under_condition=True} stas ins1)
          in
          let res1_true, res1_false =
            Fset.partition (fun sta -> sta.context.result) res1_normal
          in
          let res2_normal, res2_other =
            Rs.separate_normal
              (interp_instr_bool' inp res1_true ins2)
          in
          let res3 = interp_while (ctr-1) res2_normal in
          Rs.(let others =
                let res1_false' = {empty with normal=res1_false} in
                map (with_data ())
                  (union res1_other
                    (union res1_false' res2_other))
              in
              union res3 others)
      in
      interp_while Sem.loop_boundary
        (Fset.singleton ({context=ctx; state=sta; data=True}))

    | IPipe ins1 ins2 ->
      let stas1 = (* Behaviour in ins1 is ignored *)
        Rs.all
         (let sta' = {sta with stdout = Stdout.empty} in
          interp_instr inp ctx sta' ins1)
      in
      let res2 =
        let stas1' =
          let prepare sta1 =
            let sta' = {
              sta1.state with
              stdout = sta.stdout;
              stdin = Stdout.to_stdin sta1.state.stdout
            } in
            {context=ctx; state=sta'; data=sta1.state.stdin}
          in
          Fset.map (fun xyz -> prepare xyz) stas1
        in
        interp_instr_stdin' inp stas1' ins2
      in
      let revise sta2 =
        let sta2' = {sta2.state with stdin = sta2.data} in
        {state = sta2'; context = ctx; data=()}
      in
      Rs.map (fun xyz -> revise xyz) res2

    | IExit code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {context = ctx'; state = sta; data=()}
      in
      Rs.({empty with exit = Fset.singleton sta})

    | IReturn code -> 
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {context = ctx'; state = sta; data=()}
      in
      Rs.({empty with return_ = Fset.singleton sta})
    end

  (* Monomorphic version of `interp_instr' : input -> set (sym_state 'a) -> Rs.t 'a`
     to work around bug https://gitlab.inria.fr/why3/why3/issues/240 *)

  with interp_instr_unit' (inp:input) (stas: set (sym_state unit)) (ins:instruction) : Rs.t unit diverges =
    (* Cannot fold `stas` because `interp_instr` may not terminate *)
    let rec aux (stas: list (sym_state unit)) : Rs.t unit =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instr inp sta.context sta.state ins in
        let res' = Rs.map (with_data sta.data) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_instr_bool' (inp:input) (stas: set (sym_state bool)) (ins:instruction) : Rs.t bool diverges =
    (* Cannot fold `stas` because `interp_instr` may not terminate *)
    let rec aux (stas: list (sym_state bool)) : Rs.t bool =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instr inp sta.context sta.state ins in
        let res' = Rs.map (with_data sta.data) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_instr_stdin' (inp:input) (stas: set (sym_state stdin)) (ins:instruction) : Rs.t stdin diverges =
    (* Cannot fold `stas` because `interp_instr` may not terminate *)
    let rec aux (stas: list (sym_state stdin)) : Rs.t stdin =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instr inp sta.context sta.state ins in
        let res' = Rs.map (with_data sta.data) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_str_expr (b:bool) (inp:input) (ctx:context) (sta:state) (se:string_expression)
    : set (state, bool, string)
    diverges
  = match se with
    | SLiteral str ->
      singleton (sta, b, str)
    | SVariable var ->
      let str = Env.get ctx.var_env var String.empty in
      singleton (sta, b, str)
    | SArgument n ->
      let str = nth_argument (Cons inp.argument0 ctx.arguments) n.nat in
      singleton (sta, b, str)
    | SSubshell ins ->
      let stas =
        let sta' = {sta with stdout=Stdout.empty} in
        Rs.all (* Ignore behaviours *)
          (interp_instr inp ctx sta' ins)
      in
      let aux (sta1:sym_state unit) =
        let str = Stdout.to_string sta1.state.stdout in
        let sta1' = {sta1.state with stdout=sta.stdout} in
        let b' = sta1.context.result in
        sta1', b', str
      in
      Fset.map (fun xyz -> aux xyz) stas
    | SConcat se1 se2 ->
      let res1 = interp_str_expr b inp ctx sta se1 in
      let rec aux (res1: list (state, bool, string)) : set (state, bool, string) =
        match res1 with
        | Nil ->
          empty
        | Cons (sta1, b1, str1) res1' -> 
          let stas = interp_str_expr b1 inp ctx sta1 se2 in
          let concat t3 =
            let sta2, b2, str2 = t3 in
            sta2, b2, str1^str2
          in
          Fset.union
            (Fset.map (fun xyz -> concat xyz) stas)
            (aux res1')
        end
      in
      aux (Fset.to_list res1)
    end

  with interp_list_expr (inp:input) (ctx:context) (sta:state) (le:list_expression)
    : set (state, list string)
    diverges
  = match le with
    | Nil ->
      singleton (sta, Nil)
    | Cons (se, sp) le' ->
      let res1 = interp_str_expr True inp ctx sta se in
      let rec aux res1 =
        match res1 with
        | Nil -> empty
        | Cons (sta1, _, str1) res1' ->
          let l1 = match sp with Split -> String.split_on_default_ifs str1 | DontSplit -> Cons str1 Nil end in
          let res2 = interp_list_expr inp ctx sta1 le' in
          let concat res2 =
            let sta2, l2 = res2 in
            sta2, l1++l2
          in
          union (Fset.map (fun xyz -> concat xyz) res2)
            (aux res1')
        end
      in
      aux (Fset.to_list res1)
    end

  let function only_states_with_result (res: bool) (stas: set (sym_state unit)) : set state =
    Fset.(map (fun sta -> sta.state)
           (filter (fun sta -> notb (xorb res sta.context.result))
              stas))

  let rec interp_function_definitions (fenv:func_env) (defs:list function_definition)
    variant { defs }
  = match defs with
    | Nil -> fenv
    | Cons (id, instr) defs' ->
      interp_function_definitions (Env.set fenv id (Some instr))  defs'
    end

  let interp_program inp ctx sta pro : (set state, set state) diverges =
    let fenv = interp_function_definitions ctx.func_env pro.function_definitions in
    let res = interp_instr inp {ctx with func_env = fenv} sta pro.instruction in
    let all_res = Rs.all res in
    only_states_with_result True all_res,
    only_states_with_result False all_res
end