module Constraints

  type variable
  (** abstract type for variables denoting nodes in the file system *)

  type feature
  (** abstract type for filenames (excluding "." and ".."), named
      "feature" in the tree constraint vocabulary *)

  type clause
  (** abstract type for tree constraints, [IMPORTANT] which are always satisfiable *)

  type path
end

(** A symbolic file system.

   The only symbolic part in this intepreter *)
module Filesystem

  use list.List
  use Constraints

  (** A symbolic filesystem composed by a variable indicating root, constraints, and the
  current working directory `cwd` as feature path *)
  type filesystem = {
    root : variable;
    clause : clause;
    cwd : path;
    root0 : variable;
  }
end

module State
  use Filesystem
  clone export semantics.AbstractState
    with type filesystem = filesystem 
end

module Env
  use syntax.Syntax
  type t 'value
  val constant empty: t 'value
  val function get (env:t 'value) (id:identifier) (default:'value) : 'value
  val function set (env:t 'value) (id:identifier) (value:'value) : t 'value
  val function functional (env:t 'value) (default:'value) : identifier -> 'value
end

module Context
  use option.Option
  use list.List
  use mystring.String
  use syntax.Syntax
  use Env

  type var_env = Env.t string
  type func_env = Env.t (option instruction)

  type context = {
    var_env: var_env;
    func_env: func_env;
    arguments: list string;
    result: bool; (* previous result ($?) for input state, current result for output state *)
  }

  let constant empty_context = {
    var_env = Env.empty; 
    func_env = Env.empty;
    arguments = Nil;
    result = True;
  }

  use semantics.Context as C

  let function contextx (c:context) : C.context = {
    C.var_env = Env.functional c.var_env String.empty;
    C.func_env = Env.functional c.func_env None;
    C.arguments = c.arguments;
    C.result = c.result;
  }
end

module SymState

  use Context
  use State

  type sym_state 'a = {
    context: context;
    state: state;
    info: 'a (* Used to fiddle additional information through interp_instruction': A stdin in pipe and the last reuslt in the loops *)
  }

  let function with_info inf =
    fun sta ->
      {sta with info = inf}
end

(** The symbolic interpretation of a program results describes multiple possible results
  *)
module Results

  use symbolicAuxiliaries.Fset
  use semantics.Input
  use semantics.Behaviour
  use semantics.Semantics
  use Context
  use State
  use SymState

  type t 'a = {
    normal: set (sym_state 'a);
    exit: set (sym_state 'a);
    return_: set (sym_state 'a);
  }

  let constant empty = {
    normal = Fset.empty;
    exit = Fset.empty;
    return_ = Fset.empty;
  }

  let separate_normal res =
    res.normal, {res with normal = Fset.empty}

  let map f res = {
    normal = Fset.map f res.normal;
    exit = Fset.map f res.exit;
    return_ = Fset.map f res.return_;
  }

  let union res1 res2 = Fset.({
    normal  = union res1.normal  res2.normal;
    exit    = union res1.exit    res2.exit;
    return_ = union res1.return_ res2.return_;
  })

  let function all res =
    union res.normal (union res.exit res.return_)

  let inject (inp:input) (stas:set (sym_state 'a)) : t 'a
    ensures { all result = stas }
    ensures { forall s. mem s result.normal -> behaviour' inp (contextx s.context) = BNormal }
    ensures { forall s. mem s result.exit -> behaviour' inp (contextx s.context) = BExit }
  = let aux bhv = fun sta ->
      match bhv, behaviour' inp (contextx sta.context) with
      | BNormal, BNormal -> True
      | BExit, BExit -> True
      | _ -> False
      end
    in
    {normal = Fset.filter (aux BNormal) stas;
     exit = Fset.filter (aux BExit) stas;
     return_ = Fset.empty}
end

module Interpreter

  use bool.Bool
  use option.Option
  use list.List
  use list.Append
  use mystring.String
  use syntax.Syntax
  use semantics.Env
  use semantics.Behaviour
  use semantics.Input
  use semantics.Buffers
  use semantics.Arguments
  use semantics.Semantics as Sem
  use auxiliaries.Auxiliaries
  use symbolicAuxiliaries.Auxiliaries
  use symbolicAuxiliaries.Fset
  use State
  use Context
  use SymState
  use Results as Rs

  (* Implemented in OCaml *)
  val function interp_utility identifier (list string) state : set (state, bool)

  let rec interp_instruction (inp:input) (ctx:context) (sta:state) (ins:instruction) : Rs.t unit diverges =
    match ins with

    | IAssignment var se ->
      let str = interp_string_expression ctx sta se in
      let sta' =
        let ctx' = {
          ctx with
          var_env = Env.set ctx.var_env var str;
          result = True;
        }
        in {context = ctx'; state = sta; info = ()}
      in {Rs.empty with Rs.normal = Fset.singleton sta'}

    | ISequence ins1 ins2 ->
      let res1_normal, res1_other =
        Rs.separate_normal 
          (interp_instruction inp ctx sta ins1)
      in
      let res2 = interp_instruction_unit' inp res1_normal ins2 in
      Rs.union res2 res1_other

    | ISubshell ins ->
      let res = interp_instruction inp ctx sta ins in
      let stas = Rs.all res in
      Rs.inject inp stas

    | INot ins ->
      let res = interp_instruction inp ctx sta ins in
      let flip_result sta =
        let res' = notb sta.context.result in
        let ctx = {sta.context with result = res'} in
        {sta with context = ctx}
      in
      Rs.({
        normal = Fset.map (fun r -> flip_result r) res.normal;
        return_ = Fset.map (fun r -> flip_result r) res.return_;
        exit = res.exit})

    | INoOutput ins -> 
      let res = interp_instruction inp ctx sta ins in
      let reset_output sta =
        let sta' = {sta.state with stdout = sta.state.stdout} in
        {sta with state = sta'}
      in
      Rs.({normal = Fset.map (fun r -> reset_output r) res.normal;
           exit = Fset.map (fun r -> reset_output r) res.exit;
           return_ = Fset.map (fun r -> reset_output r) res.return_})

    | IIf ins1 ins2 ins3 ->
      let res1 = interp_instruction {inp with under_condition=True} ctx sta ins1 in
      let res1_normal, res1_other = Rs.separate_normal res1 in
      let res2 =
        let res1_true, res1_false =
          Fset.partition
            (fun sta -> sta.context.result)
            res1_normal
        in
        Rs.union
          (interp_instruction_unit' inp res1_true ins2)
          (interp_instruction_unit' inp res1_false ins3)
      in
      Rs.union res2 res1_other

    | ICallUtility id le ->
      let args, sta' = interp_list_expression inp ctx sta le in
      let res : set (state, bool) = interp_utility id args sta'.state in
      let stas =
        let inject_state r =
          let ctx = {ctx with result = snd r} in
          {context = ctx; state = fst r; info = ()}
        in
        Fset.map (fun r -> inject_state r) res
      in
      Rs.inject inp stas

    | ICallFunction id le ->
      let args, sta' = interp_list_expression inp ctx sta le in
      match Env.get ctx.func_env id None with
      | None ->
        let sta'' =
          let ctx' = {sta'.context with result = False} in
          {context = ctx'; state = sta'.state; info = ()}
        in
        Rs.inject inp (Fset.singleton sta'')
      | Some ins ->
        let res =
          let inp' = {inp with argument0 = identifier_to_string id} in
          let ctx' = {sta'.context with arguments = args} in
          interp_instruction inp' ctx' sta'.state ins
        in
        Rs.({normal = union res.normal res.return_;
             return_ = Fset.empty;
             exit = res.exit})
      end

    | IShift bn ->
      match shift_arguments (option_get (mk_nat 1) bn).nat ctx.arguments with
      | Some args ->
        let ctx' = {ctx with result = True; arguments = args} in
        let sta' = {context = ctx'; state = sta; info=()} in
        Rs.({empty with normal = Fset.singleton sta'})
      | None ->
        let ctx' = {ctx with result = False} in
        let sta' = {context = ctx'; state = sta; info=()} in
        Rs.inject inp (Fset.singleton sta')
      end

    | IForeach id le ins ->
      let strs, sta' = interp_list_expression inp ctx sta le in
      let rec aux (stas:set (sym_state bool)) (strs:list string) : Rs.t unit =
        match strs with
        | Nil ->
          let set_result sta =
            let ctx = {sta.context with result = sta.info} in
            {sta with context = ctx; info = ()}
          in
          let stas' = Fset.map (fun r -> set_result r) stas in
          Rs.({empty with normal = stas'})
        | Cons str strs' ->
          let stas' =
            let set_var sta =
              let venv = Env.set sta.context.var_env id str in
              let ctx = {sta.context with var_env = venv} in
              {sta with context = ctx}
            in
            Fset.map (fun s -> set_var s) stas
          in
          let res_normal, res_other =
            Rs.separate_normal
              (interp_instruction_bool' inp stas' ins)
          in
          let res_normal' =
            let result_as_info sta = {sta with info = sta.context.result} in
            Fset.map (fun s -> result_as_info s) res_normal
          in
          Rs.(union
               (map (with_info ()) res_other)
               (aux res_normal' strs'))
        end
      in
      aux (Fset.singleton ({sta' with info = True})) strs

    | IWhile ins1 ins2 ->
      let rec aux (stas: set (sym_state bool)) : Rs.t unit =
        let res1_normal, res1_other =
          Rs.separate_normal
            (interp_instruction_bool' {inp with under_condition=True} stas ins1)
        in
        let res1_true, res1_false =
          Fset.partition (fun sta -> sta.context.result) res1_normal
        in
        let res2_normal, res2_other =
          Rs.separate_normal
            (interp_instruction_bool' inp res1_true ins2)
        in
        let res1_false' = Rs.({empty with normal=res1_false}) in
        Rs.(union
             (map (with_info ())
               (union res2_other
                 (union res1_false' res1_other)))
             (aux res2_normal))
      in
      aux (Fset.singleton ({context=ctx; state=sta; info=True}))

    | IPipe ins1 ins2 ->
      let stas1 = (* Behaviour in ins1 is ignored *)
        Rs.all
         (let sta' = {sta with stdout = Stdout.empty} in
          interp_instruction inp ctx sta' ins1)
      in
      let res2 =
        let stas1' =
          let prepare sta1 =
            let sta' = {
              sta1.state with
              stdout = sta.stdout;
              stdin = Stdout.to_stdin sta1.state.stdout
            } in
            {context=ctx; state=sta'; info=sta1.state.stdin}
          in
          Fset.map (fun s -> prepare s) stas1
        in
        interp_instruction_stdin' inp stas1' ins2
      in
      let revise sta2 =
        let sta2' = {sta2.state with stdin = sta2.info} in
        {state = sta2'; context = ctx; info=()}
      in
      Rs.map (fun s -> revise s) res2

    | IExit code ->
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {context = ctx'; state = sta; info=()}
      in
      Rs.({empty with exit = Fset.singleton sta})

    | IReturn code -> 
      let r =
        match code with
        | RPrevious -> ctx.result
        | RSuccess -> True
        | RFailure -> False
        end
      in
      let sta =
        let ctx' = {ctx with result = r} in
        {context = ctx'; state = sta; info=()}
      in
      Rs.({empty with return_ = Fset.singleton sta})
    end

  (* Monomorphic version of `interp_instruction' : input -> set (sym_state 'a) -> Rs.t 'a`
     to work around bug https://gitlab.inria.fr/why3/why3/issues/240 *)

  with interp_instruction_unit' (inp:input) (stas: set (sym_state unit)) (ins:instruction) : Rs.t unit diverges =
    (* Cannot fold `stas` because `interp_instruction` may not terminate *)
    let rec aux (stas: list (sym_state unit)) : Rs.t unit =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instruction inp sta.context sta.state ins in
        let res' = Rs.map (with_info sta.info) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_instruction_bool' (inp:input) (stas: set (sym_state bool)) (ins:instruction) : Rs.t bool diverges =
    (* Cannot fold `stas` because `interp_instruction` may not terminate *)
    let rec aux (stas: list (sym_state bool)) : Rs.t bool =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instruction inp sta.context sta.state ins in
        let res' = Rs.map (with_info sta.info) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_instruction_stdin' (inp:input) (stas: set (sym_state stdin)) (ins:instruction) : Rs.t stdin diverges =
    (* Cannot fold `stas` because `interp_instruction` may not terminate *)
    let rec aux (stas: list (sym_state stdin)) : Rs.t stdin =
      match stas with
      | Nil ->
        Rs.empty
      | Cons sta stas' -> 
        let res = interp_instruction inp sta.context sta.state ins in
        let res' = Rs.map (with_info sta.info) res in
        Rs.union res' (aux stas')
      end
    in
    aux (Fset.to_list stas)

  with interp_string_expression ctx sta se : string diverges =
    match se with
    | SLiteral str -> str
    | SVariable var -> Env.get ctx.var_env var String.empty
    | SConcat se1 se2 ->
      let str1 = interp_string_expression ctx sta se1 in
      let str2 = interp_string_expression ctx sta se2 in
      str1^str2
    | SSubshell _ -> absurd
    | SArgument _ -> absurd
    end

  with interp_list_expression (inp:input) (ctx:context) (sta:state) le : (list string, sym_state unit)
    diverges
  = match le with
    | Nil -> Nil, {state=sta; context=ctx; info=()}
    | Cons (se, split) le' ->
      let str = interp_string_expression ctx sta se in
      let strs = match split with Split -> String.split_on_default_ifs str | DontSplit -> Cons str Nil end in
      let strs', sta = interp_list_expression inp ctx sta le' in
      strs ++ strs', sta
    end

  let function only_states_with_result (res: bool) (stas: set (sym_state unit)) : set state =
    Fset.(map (fun sta -> sta.state)
           (filter (fun sta -> notb (xorb res sta.context.result))
              stas))

  let rec interp_function_definitions (fenv:func_env) (defs:list function_definition)
    variant { defs }
  = match defs with
    | Nil -> fenv
    | Cons (id, instr) defs' ->
      interp_function_definitions (Env.set fenv id (Some instr))  defs'
    end

  let interp_program inp ctx sta pro : (set state, set state) diverges =
    let fenv = interp_function_definitions ctx.func_env pro.function_definitions in
    let res = interp_instruction inp {ctx with func_env = fenv} sta pro.instruction in
    let all_res = Rs.all res in
    only_states_with_result True all_res,
    only_states_with_result False all_res
end