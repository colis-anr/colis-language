(** List with constant concatenation and undefined order of elements *)
module ConcatList
  use int.Int
  use int.MinMax
  use bool.Bool
  use set.Fset as S
  use list.List
  use list.ListRich as L

  type t 'a = List (list 'a) | Concat (t 'a) (t 'a)

  predicate mem (x: 'a) (xs: t 'a) =
    match xs with
    | List l -> L.mem x l
    | Concat xs ys -> mem x xs \/ mem x ys
    end

  val ghost function to_set (xs: t 'a) : S.fset 'a
    ensures { forall x. mem x xs <-> S.mem x result }

  predicate (==) (s1 s2: t 'a) =
    forall x: 'a. mem x s1 <-> mem x s2

  lemma ext: forall s1 s2: t 'a.
    s1 == s2 ->
    to_set s1 = to_set s2
    by S.(to_set s1 == to_set s2)

  let predicate is_empty (xs: t 'a) = [@inline:trivial]
    match xs with
    | List Nil -> true
    | _ -> false
    end

  predicate is_valid (xs: t 'a) = [@inline:trivial]
    match xs with
    | List _ -> true
    | Concat xs ys ->
      not is_empty xs /\ not is_empty ys /\
      is_valid xs /\ is_valid ys
    end

  let rec lemma is_empty_spec (xs: t 'a)
    ensures { is_valid xs -> is_empty xs -> forall x. not mem x xs }
  = match xs with
    | List _ -> ()
    | Concat xs ys -> is_empty_spec xs; is_empty_spec ys
    end

  let rec function size (xs: t 'a) : int
    variant { xs }
    ensures { 0 <= result }
  = match xs with
    | List l -> L.length l
    | Concat xs ys -> size xs + size ys
    end

  let constant empty : t 'a = List Nil
    ensures { forall x. not mem x result }
    ensures { size result = 0 }
    ensures { is_valid result }
    ensures { is_empty result }

  let function concat (xs ys: t 'a) : t 'a
    requires { is_valid xs /\ is_valid ys }
    ensures { forall x. mem x xs -> mem x result }
    ensures { forall y. mem y ys -> mem y result }
    ensures { forall x. mem x result -> mem x xs \/ mem x ys }
    ensures { is_valid result }
  = if is_empty xs then
      ys
    else if is_empty ys then
      xs
    else
      Concat xs ys

  lemma concat_empty_left: forall c: t 'a.
    is_valid c ->
    concat empty c = c

  lemma concat_empty_right: forall c: t 'a.
    is_valid c ->
    concat c empty = c

  lemma concat_left: forall c1 c2: t 'a, x.
    is_valid c1 -> is_valid c2 ->
    mem x c1 -> mem x (concat c1 c2)

  lemma concat_right: forall c1 c2: t 'a, x.
    is_valid c1 -> is_valid c2 ->
    mem x c2 -> mem x (concat c1 c2)

  let rec function add (x: 'a) (xs: t 'a) : t 'a
    variant { xs }
    requires { is_valid xs }
    ensures { mem x result }
    ensures { forall y. mem y xs -> mem y result }
    ensures { forall y. mem y result -> x = y \/ mem y xs }
    ensures { size result = size xs + 1 }
    ensures { is_valid result }
  = match xs with
    | List l -> List (Cons x l)
    | Concat xs ys -> Concat (add x xs) ys
    end

  let function of_list (l: list 'a) : t 'a
    ensures { forall x. L.mem x l <-> mem x result }
    ensures { is_valid result }
  = List l

  let rec function to_list (xs: t 'a) : list 'a
    variant { xs }
    ensures { forall x. mem x xs <-> L.mem x result }
  = match xs with
    | List l -> l
    | Concat xs ys ->
      L.rev_append (to_list xs) (to_list ys)
    end

  let function singleton (x: 'a) : t 'a
    ensures { mem x result }
    ensures { forall y. mem y result -> y = x }
    ensures { size result = 1 }
    ensures { is_valid result }
  = add x empty

  let rec function flatten_list acc (xss: list (t 'a)) : t 'a
    variant { xss }
    requires { is_valid acc }
    requires { forall xs. L.mem xs xss -> is_valid xs }
    ensures { forall x. mem x acc -> mem x result }
    ensures { forall xs x. L.mem xs xss -> mem x xs -> mem x result }
    ensures { forall x. mem x result -> mem x acc \/ exists xs. L.mem xs xss /\ mem x xs }
    ensures { is_valid result }
  = match xss with
    | Nil -> acc
    | Cons xs xss' ->
      assert { is_valid xs };
      flatten_list (concat xs acc) xss'
    end

  let rec function flatten' acc (xss: t (t 'a)) : t 'a
    variant { xss }
    requires { is_valid acc }
    requires { forall xs. mem xs xss -> is_valid xs }
    ensures { forall x. mem x acc -> mem x result }
    ensures { forall xs x. mem xs xss -> mem x xs -> mem x result }
    ensures { forall x. mem x result -> mem x acc \/ exists xs. mem xs xss /\ mem x xs }
    ensures { is_valid result }
  = match xss with
    | List l -> flatten_list acc l
    | Concat xs ys -> flatten' (flatten' acc xs) ys
    end

  let function flatten (xss: t (t 'a)) : t 'a
    requires { forall xs. mem xs xss -> is_valid xs }
    ensures { forall xs x. mem xs xss -> mem x xs -> mem x result }
    ensures { forall x. mem x result -> exists xs. mem xs xss /\ mem x xs }
    ensures { is_valid result }
  = flatten' empty xss

  let rec function list_map (acc: t 'b) (f: 'a -> 'b) (xs: list 'a) : t 'b
    variant { xs }
    requires { is_valid acc }
    ensures { forall y. mem y acc -> mem y result }
    ensures { forall x. L.mem x xs -> mem (f x) result }
    ensures { forall y. mem y result -> mem y acc \/ (exists x. L.mem x xs /\ y = f x) }
    ensures { is_valid result }
  = match xs with
    | Nil -> acc
    | Cons x xs' -> list_map (add (f x) acc) f xs'
    end

  let rec function map' (acc: t 'b) (f: 'a -> 'b) (xs: t 'a) : t 'b
    variant { xs }
    requires { is_valid acc }
    ensures { forall y. mem y acc -> mem y result }
    ensures { forall x. mem x xs -> mem (f x) result }
    ensures { forall y. mem y result -> mem y acc \/ (exists x. mem x xs /\ y = f x) }
    ensures { is_valid result }
  = match xs with
    | List l -> list_map acc f l
    | Concat xs ys -> map' (map' acc f xs) f ys
    end

  let function map (f: 'a -> 'b) (xs: t 'a) : t 'b
    ensures { forall x. mem x xs -> mem (f x) result }
    ensures { forall y. mem y result -> exists x. mem x xs /\ y = f x }
    ensures { is_valid result }
  = map' empty f xs

  let rec function list_filter (acc: t 'a) (p: 'a -> bool) (xs: list 'a) : t 'a
    variant { xs }
    requires { is_valid acc }
    requires { forall x. mem x acc -> p x }
    ensures { forall x. mem x acc -> mem x result }
    ensures { forall x. L.mem x xs -> p x -> mem x result }
    ensures { forall x. L.mem x xs -> not p x -> not mem x result }
    ensures { forall x. mem x result -> p x }
    ensures { forall x. mem x result -> mem x acc \/ L.mem x xs }
    ensures { is_valid result }
  = match xs with
    | Nil -> acc
    | Cons x xs' ->
      let acc' = if p x then add x acc else acc in
      list_filter acc' p xs'
    end
    
  let rec function filter' (acc: t 'a) (p: 'a -> bool) (xs: t 'a) : t 'a
    variant { xs }
    requires {is_valid acc }
    requires { forall x. mem x acc -> p x }
    ensures { forall x. mem x acc -> mem x result }
    ensures { forall x. mem x xs -> p x -> mem x result }
    ensures { forall x. mem x xs -> not p x -> not mem x result }
    ensures { forall x. mem x result -> p x }
    ensures { forall x. mem x result -> mem x acc \/ mem x xs }
    ensures { is_valid result }
  = match xs with
    | List l -> list_filter acc p l
    | Concat xs ys -> filter' (filter' acc p xs) p ys
    end

  let function filter (p: 'a -> bool) (xs: t 'a) : t 'a
    ensures { forall x. mem x xs -> p x -> mem x result }
    ensures { forall x. mem x result -> p x }
    ensures { forall x. mem x result -> mem x xs }
    ensures { is_valid result }
  = filter' empty p xs

  let rec function list_partition (acc: (t 'a, t 'a)) (p: 'a -> bool) (xs: list 'a) : (res1: t 'a, res2: t 'a)
    variant { xs }
    requires { let acc1, acc2 = acc in is_valid acc1 /\ is_valid acc2 }
    requires { let acc1, acc2 = acc in (forall x. mem x acc1 -> p x) /\ (forall x. mem x acc2 -> not p x) }
    ensures { forall x. L.mem x xs -> mem x res1 \/ mem x res2 }
    ensures { let acc1, acc2 = acc in (forall x. mem x acc1 -> mem x res1) /\ (forall x. mem x acc2 -> mem x res2) }
    ensures { let acc1, _ = acc in forall x. mem x res1 -> p x /\ (mem x acc1 \/ L.mem x xs) }
    ensures { let _, acc2 = acc in forall x. mem x res2 -> not p x /\ (mem x acc2 \/ L.mem x xs) }
    ensures { is_valid res1 /\ is_valid res2 }
  = match xs with
    | Nil -> acc
    | Cons x xs' ->
      let acc1, acc2 = acc in
      let acc' = if p x then add x acc1, acc2 else acc1, add x acc2 in
      list_partition acc' p xs'
    end

  let rec function partition' (acc: (t 'a, t 'a)) (p: 'a -> bool) (xs: t 'a) : (res1: t 'a, res2: t 'a)
    variant { xs }
    requires { is_valid xs }
    requires { let acc1, acc2 = acc in is_valid acc1 /\ is_valid acc2 }
    requires { let acc1, acc2 = acc in (forall x. mem x acc1 -> p x) /\ (forall x. mem x acc2 -> not p x) }
    ensures { forall x. mem x xs -> mem x res1 \/ mem x res2 }
    ensures { let acc1, acc2 = acc in (forall x. mem x acc1 -> mem x res1) /\ (forall x. mem x acc2 -> mem x res2) }
    ensures { let acc1, _ = acc in forall x. mem x res1 -> p x /\ (mem x acc1 \/ mem x xs) }
    ensures { let _, acc2 = acc in forall x. mem x res2 -> not p x /\ (mem x acc2 \/ mem x xs) }
    ensures { is_valid res1 /\ is_valid res2 }
  = match xs with
    | List l -> list_partition acc p l
    | Concat xs ys -> partition' (partition' acc p xs) p ys
    end

  let function partition (p: 'a -> bool) (xs: t 'a) : (res1: t 'a, res2: t 'a)
    requires { is_valid xs }
    ensures { forall x. mem x xs -> mem x res1 \/ mem x res2 }
    ensures { forall x. mem x res1 -> p x /\ mem x xs }
    ensures { forall x. mem x res2 -> not p x /\ mem x xs }
    ensures { is_valid res1 /\ is_valid res2 }
  = partition' (empty, empty) p xs

  let function bind (f: 'a -> t 'b) (xs: t 'a) : t 'b
    requires { is_valid xs }
    requires { forall x. is_valid (f x) }
    ensures { forall x. mem x xs -> forall y. mem y (f x) -> mem y result }
    ensures { forall y. mem y result -> exists x. mem x xs /\ mem y (f x) }
    ensures { is_valid result }
  = flatten (map f xs)
end

(* module Collection *)

(*   use list.ListRich as L *)
(*   use set.Fset as S *)
(*   use int.Int *)

(*   type t 'a *)

(*   (\** Membership is all we have to characterize a collection *\) *)
(*   predicate mem (x: 'a) (c: t 'a) *)

(*   predicate (==) (s1 s2: t 'a) = *)
(*     forall x: 'a. mem x s1 <-> mem x s2 *)

(*   (\* Can it be a lemma? Would require propositional extensionality? *\) *)
(*   axiom extensionality: forall s1 s2: t 'a. *)
(*     s1 == s2 -> s1 = s2 *)

(*   val function of_list (l: L.list 'a) : t 'a *)
(*     ensures { forall x. L.mem x l <-> mem x result } *)

(*   val function to_list (c: t 'a) : L.list 'a *)
(*     ensures { forall x. mem x c <-> L.mem x result } *)

(*   val constant size (c: t 'a) : int *)
(*     ensures { 0 <= result } *)

(*   val constant empty : t 'a *)
(*     ensures { forall x. not mem x result } *)
(*     ensures { size result = 0 } *)

(*   val function add (x: 'a) (c: t 'a) : t 'a *)
(*     ensures { mem x result } *)
(*     ensures { forall y. mem y c -> mem y result } *)
(*     ensures { forall y. mem y result -> x = y \/ mem y c } *)
(*     ensures { 0 <> size result } *)
(*     ensures { not mem x c -> size result = size c + 1 } *)
(*     ensures { (\* We dont decide here if the collection keeps duplicates *\) *)
(*               mem x c -> size result = size c \/ size result = size c + 1 } *)

(*   let function singleton (x: 'a) : t 'a *)
(*     ensures { mem x result } *)
(*     ensures { forall y. mem y result -> y = x } *)
(*     ensures { size result = 1 } *)
(*   = add x empty *)

(*   val function map (f: 'a -> 'b) (c: t 'a) : t 'b *)
(*     ensures { forall x. mem x c -> mem (f x) result } *)
(*     ensures { forall y. mem y result -> exists x. mem x c /\ y = f x } *)

(*   val function filter (p: 'a -> bool) (c: t 'a) : t 'a *)
(*     ensures { forall x. mem x c -> p x -> mem x result } *)
(*     ensures { forall x. not p x -> not mem x result } *)
(*     ensures { forall x. mem x result -> p x /\ mem x c } *)

(*   val function partition (p: 'a -> bool) (c: t 'a) : (pos: t 'a, neg: t 'a) *)
(*     ensures { forall x. mem x c -> mem x pos \/ mem x neg } *)
(*     ensures { forall x. mem x pos -> p x /\ mem x c } *)
(*     ensures { forall x. mem x neg -> not p x /\ mem x c } *)

(*   val function union (c1 c2: t 'a) : t 'a *)
(*     ensures { forall x. mem x c1 -> mem x result } *)
(*     ensures { forall x. mem x c2 -> mem x result } *)
(*     ensures { forall x. mem x result -> mem x c1 \/ mem x c2 } *)

(*   val flatten (c: t (t 'a)) : t 'a *)
(*     ensures { forall xs x. mem xs c -> mem x xs -> mem x result } *)
(*     ensures { forall x. mem x result -> exists xs. mem xs c /\ mem x xs } *)

(*   let function bind (f: 'a -> t 'b) (c: t 'a) : t 'b *)
(*     ensures { forall x. mem x c -> forall y. mem y (f x) -> mem y result } *)
(*     ensures { forall y. mem y result -> exists x. mem x c /\ mem y (f x) } *)
(*   = flatten (map f c) *)
(* end *)